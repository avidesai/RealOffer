"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LangSmithOTLPSpanProcessor = void 0;
exports.isTraceableSpan = isTraceableSpan;
const sdk_trace_base_1 = require("@opentelemetry/sdk-trace-base");
const constants_js_1 = require("./constants.cjs");
const utils_js_1 = require("./utils.cjs");
const run_trees_js_1 = require("../../run_trees.cjs");
const NANOSECOND_DIGITS = 9;
const MICROSECOND_DIGITS = 6;
function isTraceableSpan(span) {
    return (span.attributes[constants_js_1.LANGSMITH_TRACEABLE] === "true" ||
        typeof span.attributes["ai.operationId"] === "string");
}
/**
 * Convert hrTime to timestamp, for example "2019-05-14T17:00:00.000123Z"
 * @param time
 */
function hrTimeToTimeStamp(time) {
    const precision = NANOSECOND_DIGITS;
    const tmp = `${"0".repeat(precision)}${time[1]}Z`;
    const nanoString = tmp.substring(tmp.length - precision - 1);
    const date = new Date(time[0] * 1000).toISOString();
    // We only need 6 digits of precision for the dotted order
    return `${date.replace("000Z", nanoString.slice(0, MICROSECOND_DIGITS))}Z`;
}
function getParentSpanId(span) {
    // Backcompat shim to support OTEL 1.x and 2.x
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (span.parentSpanId ?? span.parentSpanContext?.spanId ?? undefined);
}
/**
 * Span processor that filters out spans that are not LangSmith-related and
 * usually should not be traced.
 */
class LangSmithOTLPSpanProcessor extends sdk_trace_base_1.BatchSpanProcessor {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "traceMap", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
    }
    onStart(span, parentContext) {
        if (!this.traceMap[span.spanContext().traceId]) {
            this.traceMap[span.spanContext().traceId] = {
                spanInfo: {},
                spanCount: 0,
            };
        }
        this.traceMap[span.spanContext().traceId].spanCount++;
        const isTraceable = isTraceableSpan(span);
        const parentSpanId = getParentSpanId(span);
        let currentCandidateParentSpanId = parentSpanId;
        let traceableParentId;
        let parentDottedOrder;
        // LangSmith uses the first span's id as the trace id, NOT the actual OTEL trace id
        // Default to the current span if no parent information is present
        let lsTraceId = (0, utils_js_1.getUuidFromOtelSpanId)(span.spanContext().spanId);
        while (currentCandidateParentSpanId) {
            const currentSpanInfo = this.traceMap[span.spanContext().traceId].spanInfo[currentCandidateParentSpanId];
            if (currentSpanInfo?.isTraceable) {
                traceableParentId = currentCandidateParentSpanId;
                parentDottedOrder = currentSpanInfo.dottedOrder;
                lsTraceId = currentSpanInfo.lsTraceId;
                break;
            }
            currentCandidateParentSpanId = currentSpanInfo?.parentSpanId;
        }
        const startTimestamp = hrTimeToTimeStamp(span.startTime);
        const spanUuid = (0, utils_js_1.getUuidFromOtelSpanId)(span.spanContext().spanId);
        const dottedOrderComponent = (0, run_trees_js_1.stripNonAlphanumeric)(startTimestamp) + spanUuid;
        const currentDottedOrder = parentDottedOrder
            ? `${parentDottedOrder}.${dottedOrderComponent}`
            : dottedOrderComponent;
        this.traceMap[span.spanContext().traceId].spanInfo[span.spanContext().spanId] = {
            isTraceable,
            lsTraceId,
            spanId: span.spanContext().spanId,
            parentSpanId,
            dottedOrder: currentDottedOrder,
        };
        if (!traceableParentId) {
            span.attributes[constants_js_1.LANGSMITH_IS_ROOT] = true;
        }
        else {
            span.attributes[constants_js_1.LANGSMITH_PARENT_RUN_ID] =
                (0, utils_js_1.getUuidFromOtelSpanId)(traceableParentId);
        }
        span.attributes[constants_js_1.LANGSMITH_DOTTED_ORDER] = currentDottedOrder;
        span.attributes[constants_js_1.LANGSMITH_TRACE_ID] = lsTraceId;
        if (isTraceable) {
            super.onStart(span, parentContext);
        }
    }
    onEnd(span) {
        const traceInfo = this.traceMap[span.spanContext().traceId];
        if (!traceInfo)
            return;
        const spanInfo = traceInfo.spanInfo[span.spanContext().spanId];
        if (!spanInfo)
            return;
        // Decrement span count and cleanup trace if all spans are done
        traceInfo.spanCount--;
        if (traceInfo.spanCount <= 0) {
            delete this.traceMap[span.spanContext().traceId];
        }
        if (spanInfo.isTraceable) {
            super.onEnd(span);
        }
    }
    async shutdown() {
        await run_trees_js_1.RunTree.getSharedClient().awaitPendingTraceBatches();
        await super.shutdown();
    }
}
exports.LangSmithOTLPSpanProcessor = LangSmithOTLPSpanProcessor;
