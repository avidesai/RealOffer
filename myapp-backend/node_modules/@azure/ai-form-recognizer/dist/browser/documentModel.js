// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { isAcronymic, uncapitalize } from "./util.js";
/**
 * Checks a field value against a schema and converts it into a strong idiomatic DocumentField,
 * @internal
 * @param fieldName - the name of the field (used in diagnostics)
 * @param schema - the field's schema
 * @param field - the raw DocumentField value
 * @returns
 */
function extractField(fieldName, schema, field) {
    if (schema.type !== field.kind) {
        throw new Error(`Schema violation: ${fieldName} had type "${field.kind}", but expected "${schema.type}"`);
    }
    // Objects need to be handled specially, so that we can camelCase the field names.
    if (field.kind === "object") {
        const result = {};
        for (const [subFieldName, subFieldSchema] of Object.entries(schema.properties)) {
            if (field.properties[subFieldName] !== undefined && field.properties[subFieldName] !== null) {
                const trueFieldName = (isAcronymic(subFieldName) ? subFieldName : uncapitalize(subFieldName)).replace(/\s/g, "");
                result[trueFieldName] = extractField(fieldName + "." + subFieldName, subFieldSchema, field.properties[subFieldName]);
            }
        }
        return Object.assign(Object.assign({}, field), { properties: result });
    }
    else if (field.kind === "array") {
        return Object.assign(Object.assign({}, field), { values: field.values.map((val, idx) => extractField(fieldName + "[" + idx + "]", schema.items, val)) });
    }
    else
        return field;
}
/**
 * Create a DocumentModel that performs analysis using the given schema.
 *
 * The types of `documents` are created from the schema, so they are `unknown` unless they are asserted to be a
 * different type.
 *
 * @hidden
 * @param schema - model schema contents
 * @returns - a DocumentModel that encodes the schema
 */
export function createModelFromSchema(schema) {
    return {
        modelId: schema.modelId,
        apiVersion: schema.apiVersion,
        transformResult(baseResult) {
            var _a, _b, _c;
            const hasDocuments = Object.entries((_a = schema.docTypes) !== null && _a !== void 0 ? _a : {}).length > 0;
            return Object.assign(Object.assign({}, baseResult), { documents: hasDocuments
                    ? (_b = baseResult.documents) === null || _b === void 0 ? void 0 : _b.map(toDocument)
                    : ((_c = baseResult.documents) !== null && _c !== void 0 ? _c : []) });
            function toDocument(document) {
                var _a;
                const result = {};
                const model = (_a = schema.docTypes) === null || _a === void 0 ? void 0 : _a[document.docType];
                if (model === undefined) {
                    throw new Error(`Unexpected document type "${document.docType}" in result using model "${schema.modelId}"`);
                }
                for (const [fieldName, fieldSchema] of Object.entries(model.fieldSchema)) {
                    if (document.fields &&
                        document.fields[fieldName] !== undefined &&
                        document.fields[fieldName] !== null) {
                        const trueFieldName = (isAcronymic(fieldName) ? fieldName : uncapitalize(fieldName)).replace(/\s/g, "");
                        result[trueFieldName] = extractField(fieldName, fieldSchema, document.fields[fieldName]);
                    }
                }
                return Object.assign(Object.assign({}, document), { fields: result });
            }
        },
    };
}
//# sourceMappingURL=documentModel.js.map