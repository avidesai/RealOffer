{"version":3,"file":"delayMs.js","sourceRoot":"","sources":["../../../../src/lro/util/delayMs.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAGlC,OAAO,EAAE,UAAU,EAAE,MAAM,yBAAyB,CAAC;AACrD,OAAO,EAAE,QAAQ,EAAE,MAAM,eAAe,CAAC;AAezC;;;;;;;;;;;;;;;;;;GAkBG;AACH,MAAM,UAAU,OAAO,CACrB,EAAU,EACV,WAAwC;IAExC,IAAI,OAAO,GAAG,KAAK,CAAC;IACpB,IAAI,QAA0C,CAAC;IAE/C,WAAW,aAAX,WAAW,uBAAX,WAAW,CAAE,gBAAgB,CAAC,OAAO,EAAE,GAAG,EAAE;QAC1C,OAAO,GAAG,IAAI,CAAC;QACf,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAG,IAAI,UAAU,CAAC,4BAA4B,CAAC,CAAC,CAAC;IAC3D,CAAC,CAAC,CAAC;IAEH,OAAO,MAAM,CAAC,MAAM,CAClB,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QACpC,IAAI,KAAoC,CAAC;QACzC,QAAQ,GAAG,CAAC,CAAC,EAAE,EAAE;YACf,QAAQ,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;YAC9B,MAAM,CAAC,CAAC,CAAC,CAAC;QACZ,CAAC,CAAC;QAEF,6GAA6G;QAC7G,+FAA+F;QAC/F,IAAI,OAAO,EAAE,CAAC;YACZ,QAAQ,CAAC,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC,CAAC;QAClE,CAAC;aAAM,CAAC;YACN,KAAK,GAAG,UAAU,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;QAClC,CAAC;IACH,CAAC,CAAC,EACF;QACE,MAAM,EAAE,GAAG,EAAE;YACX,OAAO,GAAG,IAAI,CAAC;YACf,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAG,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC,CAAC;QACxD,CAAC;KACF,CACF,CAAC;AACJ,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { AbortSignalLike } from \"@azure/abort-controller\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { maybemap } from \"../../util.js\";\n\ntype CancellationToken = Parameters<typeof clearTimeout>[0];\n\n/**\n * A PromiseLike object that supports cancellation.\n * @internal\n */\nexport interface CancelablePromiseLike<T> extends PromiseLike<T> {\n  /**\n   * Cancel the promise (cause it to reject).\n   */\n  cancel(): void;\n}\n\n/**\n * A promise that delays resolution until a certain amount of time (in milliseconds) has passed, with facilities for\n * robust cancellation.\n *\n * ### Example:\n *\n * ```ts snippet:ignore\n * let toCancel;\n *\n * // Wait 20 seconds, and optionally allow the function to be cancelled.\n * await delayMs(20000, (cancel) => { toCancel = cancel });\n *\n * // ... if `toCancel` is called before the 20 second timer expires, then the delayMs promise will reject.\n * ```\n *\n * @internal\n * @param ms - the number of milliseconds to wait before resolving\n * @param cb - a callback that can provide the caller with a cancellation function\n */\nexport function delayMs(\n  ms: number,\n  abortSignal: AbortSignalLike | undefined,\n): CancelablePromiseLike<void> {\n  let aborted = false;\n  let toReject: ((e: Error) => void) | undefined;\n\n  abortSignal?.addEventListener(\"abort\", () => {\n    aborted = true;\n    toReject?.(new AbortError(\"The operation was aborted.\"));\n  });\n\n  return Object.assign(\n    new Promise<void>((resolve, reject) => {\n      let token: CancellationToken | undefined;\n      toReject = (e) => {\n        maybemap(token, clearTimeout);\n        reject(e);\n      };\n\n      // In the rare case that the operation is _already_ aborted, we will reject instantly. This could happen, for\n      // example, if the user calls the cancellation function immediately without yielding execution.\n      if (aborted) {\n        toReject(new Error(\"The operation was cancelled prematurely.\"));\n      } else {\n        token = setTimeout(resolve, ms);\n      }\n    }),\n    {\n      cancel: () => {\n        aborted = true;\n        toReject?.(new Error(\"The operation was cancelled.\"));\n      },\n    },\n  );\n}\n"]}