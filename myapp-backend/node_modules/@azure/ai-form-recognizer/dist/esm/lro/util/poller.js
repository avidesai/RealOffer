// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { delayMs } from "./delayMs.js";
import { AbortError } from "@azure/abort-controller";
const DEFAULT_POLLING_INTERVAL = 5000;
/**
 * Uniform poller implementation, creates a poller based on a PollerSpec.
 *
 * @internal
 */
export async function lro(spec, pollingInterval, initAbortSignal) {
    let serverDrivenDelay;
    const initContext = {
        abortSignal: initAbortSignal,
        updateDelay: (interval) => {
            serverDrivenDelay = interval;
        },
    };
    if (initAbortSignal === null || initAbortSignal === void 0 ? void 0 : initAbortSignal.aborted) {
        throw new AbortError("The operation was aborted.");
    }
    let state = await spec.init(initContext);
    // Job handling. If `job` is defined, then there is an active `pollUntilDone` call on this poller.
    // Call `cancelJob` to interrupt the polling loop (awaiters will throw).
    let job;
    let cancelJob;
    const handlers = new Map();
    const handleProgressEvents = async () => handlers.forEach((h) => h(state));
    const self = {
        onProgress: (callback) => {
            const s = Symbol();
            handlers.set(s, callback);
            return () => handlers.delete(s);
        },
        stopPolling: () => cancelJob === null || cancelJob === void 0 ? void 0 : cancelJob(),
        poll: async (options) => {
            state = await spec.poll({
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
                updateDelay: (interval) => {
                    serverDrivenDelay = interval;
                },
            }, state);
            handleProgressEvents();
        },
        pollUntilDone: (options) => (job !== null && job !== void 0 ? job : (job = (async () => {
            // Technically, the poller could complete during initialization
            if (!self.isDone()) {
                // Poll once to get the ball rolling, this avoids a delay if the operation completes immediately
                await self.poll(options);
                while (!self.isDone()) {
                    const finalPollingInterval = Math.max(serverDrivenDelay !== null && serverDrivenDelay !== void 0 ? serverDrivenDelay : 0, pollingInterval !== null && pollingInterval !== void 0 ? pollingInterval : DEFAULT_POLLING_INTERVAL);
                    const delay = delayMs(finalPollingInterval, options === null || options === void 0 ? void 0 : options.abortSignal);
                    cancelJob = delay.cancel;
                    await delay.then(() => self.poll());
                }
            }
            const result = self.getResult();
            // The state says it's done, so we know we are in either a success case, an error case, or an _internal_ error.
            if (result !== undefined)
                return result;
            else if (state.error !== undefined)
                throw state.error;
            // Unreachable
            else {
                throw new Error(`Internal Client Error: analysis poller completed without success or error: ${state}`);
            }
        })().finally(() => {
            job = undefined;
        }))),
        // The poller is stopped if there is no job running
        isStopped: () => !!job,
        // The operation is complete if either a result or error is produced
        isDone: () => !!state.result || !!state.error,
        // In FR, all operations run to completion
        cancelOperation() {
            throw new Error("The Azure Form Recognizer service does not support operation cancellation.");
        },
        getOperationState: () => state,
        getResult: () => state.result,
        toString: () => spec.serialize(state),
    };
    return self;
}
//# sourceMappingURL=poller.js.map