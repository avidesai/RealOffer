// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { FormRecognizerError } from "../error.js";
import { toAnalyzedDocumentFieldsFromGenerated } from "../models/fields.js";
import { toBoundingPolygon, toBoundingRegions, toDocumentTableFromGenerated, toKeyValuePairFromGenerated, } from "../transforms/polygon.js";
/**
 * Transform a REST-level Document response object into the more strongly-typed AnalyzedDocument.
 *
 * @internal
 * @param document - a REST-level document response object
 * @returns an AnalyzedDocument (which has had its fields mapped to stronger DocumentField types)
 */
export function toAnalyzedDocumentFromGenerated(document) {
    var _a;
    return Object.assign(Object.assign({}, document), { boundingRegions: toBoundingRegions(document.boundingRegions), fields: toAnalyzedDocumentFieldsFromGenerated((_a = document.fields) !== null && _a !== void 0 ? _a : {}) });
}
/**
 * Tests if one span contains another, by testing that the outer span starts before or at the same character as the
 * inner span, and that the end position of the outer span is greater than or equal to the end position of the inner
 * span.
 *
 * @internal
 * @param outer - the outer (potentially containing) span
 * @param inner - the span to test if `outer` contains
 * @returns true if `inner` is contained inside of `outer`.
 */
export function contains(outer, inner) {
    return outer.offset <= inner.offset && outer.offset + outer.length >= inner.offset + inner.length;
}
/**
 * Make an empty generator. This might seem silly, but it's useful for satisfying invariants.
 */
function* empty() {
    /* intentionally empty */
}
/**
 * Produces an iterator of the given items starting from the given index.
 *
 * @param items - the items to iterate over
 * @param idx - the index of the first item to begin iterating from
 */
export function* iterFrom(items, idx) {
    let i = idx;
    while (i < items.length) {
        yield items[i++];
    }
}
export function toDocumentLineFromGenerated(generated, page) {
    generated.words = () => {
        var _a, _b;
        return fastGetChildren(iterFrom(generated.spans, 0), (_b = (_a = page.words) === null || _a === void 0 ? void 0 : _a.map((word) => {
            return Object.assign(Object.assign({}, word), { polygon: toBoundingPolygon(word.polygon) });
        })) !== null && _b !== void 0 ? _b : []);
    };
    generated.polygon = toBoundingPolygon(generated.polygon);
    Object.defineProperty(generated, "words", {
        enumerable: false,
    });
    return generated;
}
export function toDocumentPageFromGenerated(generated) {
    var _a, _b, _c, _d, _e;
    return Object.assign(Object.assign({}, generated), { lines: (_a = generated.lines) === null || _a === void 0 ? void 0 : _a.map((line) => toDocumentLineFromGenerated(line, generated)), selectionMarks: (_b = generated.selectionMarks) === null || _b === void 0 ? void 0 : _b.map((mark) => (Object.assign(Object.assign({}, mark), { polygon: toBoundingPolygon(mark.polygon) }))), words: (_c = generated.words) === null || _c === void 0 ? void 0 : _c.map((word) => (Object.assign(Object.assign({}, word), { polygon: toBoundingPolygon(word.polygon) }))), barcodes: (_d = generated.barcodes) === null || _d === void 0 ? void 0 : _d.map((barcode) => (Object.assign(Object.assign({}, barcode), { polygon: toBoundingPolygon(barcode.polygon) }))), formulas: (_e = generated.formulas) === null || _e === void 0 ? void 0 : _e.map((formula) => (Object.assign(Object.assign({}, formula), { polygon: toBoundingPolygon(formula.polygon) }))) });
}
/**
 * Binary search through an array of items to find the first item that could possibly be contained by the given span,
 * then return an iterator beginning from that item.
 *
 * This allows a program to quickly find the first relevant item in the array for consideration when testing for span
 * inclusion.
 *
 * @internal
 * @param span - the span to use when testing each individual item
 * @param items - an array of items to binary search through
 * @returns an iterator beginning from the item identified by the search
 */
export function iteratorFromFirstMatchBinarySearch(span, items) {
    let idx = Math.floor(items.length / 2);
    let prevIdx = idx;
    let min = 0;
    let max = items.length;
    const found = () => { var _a, _b, _c; 
    // The item is found if it starts after the current span and the item before it does not. That means it is the first
    // item in the array that could be a child if the spans are sorted.
    return items[idx].span.offset >= span.offset && ((_c = (_b = (_a = items[idx - 1]) === null || _a === void 0 ? void 0 : _a.span) === null || _b === void 0 ? void 0 : _b.offset) !== null && _c !== void 0 ? _c : -1) < span.offset; };
    // Binary search to find the first element that could be a child
    do {
        if (found()) {
            return iterFrom(items, idx);
        }
        else if (span.offset > items[idx].span.offset) {
            min = prevIdx = idx;
            idx = Math.floor(idx + (max - idx) / 2);
        }
        else {
            max = prevIdx = idx;
            idx = Math.floor(idx - (idx - min) / 2);
        }
    } while (idx !== prevIdx);
    // This might seem weird, but it's a simple way to make the types a little more elegant.
    return empty();
}
/**
 * This fast algorithm tests the elements of `childArray` for inclusion in any of the given `spans`, assuming that both
 * the spans and child items are sorted.
 *
 * INVARIANT: the items in both the `spans` iterator and `childrenArray` MUST BE SORTED INCREASING by span _offset_.
 *
 * @internal
 * @param spans - the spans that contain the child elements
 * @param childrenArray - an array of child items (items that have spans) to test for inclusion in the spans
 * @returns - an IterableIterator of child items that are included in any span in the `spans` iterator
 */
export function* fastGetChildren(spans, childrenArray) {
    let curSpan = spans.next();
    // Need to exit early if there are no spans.
    if (curSpan.done) {
        return;
    }
    const children = iteratorFromFirstMatchBinarySearch(curSpan.value, childrenArray);
    let curChild = children.next();
    while (!(curChild.done || curSpan.done)) {
        if (contains(curSpan.value, curChild.value.span)) {
            // The span is contained, so yield the current child and advance it.
            yield curChild.value;
            curChild = children.next();
        }
        else if (curSpan.value.offset + curSpan.value.length < curChild.value.span.offset) {
            // The current span ends before the next potential child starts, so advance the span
            curSpan = spans.next();
        }
        else {
            // The current child was not contained in the current span, so advance to the next child.
            curChild = children.next();
        }
    }
}
/**
 * Convert a generated AnalyzeResult into a convenience layer AnalyzeResult.
 * @internal
 */
export function toAnalyzeResultFromGenerated(result) {
    var _a, _b, _c, _d;
    return {
        apiVersion: result.apiVersion,
        modelId: result.modelId,
        content: result.content,
        pages: result.pages.map((page) => toDocumentPageFromGenerated(page)),
        tables: (_a = result.tables) === null || _a === void 0 ? void 0 : _a.map((table) => toDocumentTableFromGenerated(table)),
        keyValuePairs: (_b = result.keyValuePairs) === null || _b === void 0 ? void 0 : _b.map((pair) => toKeyValuePairFromGenerated(pair)),
        languages: result.languages,
        styles: result.styles,
        paragraphs: (_c = result.paragraphs) === null || _c === void 0 ? void 0 : _c.map((para) => (Object.assign(Object.assign({}, para), { boundingRegions: toBoundingRegions(para.boundingRegions) }))),
        documents: (_d = result.documents) === null || _d === void 0 ? void 0 : _d.map(toAnalyzedDocumentFromGenerated),
    };
}
/**
 * Converts an AnalyzeResultOperation (LRO response) to a DocumentAnalysisPollOperationState
 * @internal
 */
export function toDocumentAnalysisPollOperationState(definition, modelId, operationLocation, response) {
    return {
        status: response.status,
        modelId: modelId,
        lastUpdatedOn: response.lastUpdatedOn,
        createdOn: response.createdOn,
        operationLocation,
        result: response.analyzeResult && definition.transformResult(response.analyzeResult),
        error: response.error && new FormRecognizerError(response.error),
        isCancelled: false, // Not supported
        isStarted: response.status !== "notStarted",
        isCompleted: response.status === "succeeded",
    };
}
//# sourceMappingURL=analysis.js.map