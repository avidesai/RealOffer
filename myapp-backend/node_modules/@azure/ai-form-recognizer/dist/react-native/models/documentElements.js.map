{"version":3,"file":"documentElements.js","sourceRoot":"","sources":["../../../src/models/documentElements.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { Point2D } from \"../transforms/polygon.js\";\nimport type {\n  DocumentSpan,\n  DocumentTableCellKind,\n  DocumentField as GeneratedDocumentField,\n  LengthUnit,\n  ParagraphRole,\n  SelectionMarkState,\n  DocumentBarcodeKind,\n  DocumentFormulaKind,\n} from \"../generated/index.js\";\nimport { AnalyzeDocumentOptions } from \"../options/index.js\";\n\n/** Simple document elements such as words, selection marks and lines are bounded by the polygon. */\nexport interface HasBoundingPolygon {\n  /** Bounding polygon of the entity. */\n  polygon?: Point2D[];\n}\n\n// ------------------------------------\n// Following are the interfaces that are redefined with the property `polygon?: Point2D[];`\n// instead of the generated `polygon?: number[];` for the interfaces in the generated code with the same names.\n//\n// To avoid going out-of-sync with the generated types, we test the re-constructed interfaces are following the shapes in the generated interfaces in the following test file.\n// `test/internal/convenienceModelAssignability.spec.ts`\n//\n// If the generated code is updated and if there are new additions in the generated interfaces, the function calls \"checkAssign\" would fail in the test file, which would mean we need to revisit the re-constructed shapes here.\n\n/** Bounding polygon on a specific page of the input. */\nexport interface BoundingRegion extends HasBoundingPolygon {\n  /** 1-based page number of page containing the bounding region. */\n  pageNumber: number;\n}\n\n/** A word object consisting of a contiguous sequence of characters.  For non-space delimited languages, such as Chinese, Japanese, and Korean, each character is represented as its own word. */\nexport interface DocumentWord extends HasBoundingPolygon {\n  /** Text content of the word. */\n  content: string;\n  /** Location of the word in the reading order concatenated content. */\n  span: DocumentSpan;\n  /** Confidence of correctly extracting the word. */\n  confidence: number;\n}\n\n/** A selection mark object representing check boxes, radio buttons, and other elements indicating a selection. */\nexport interface DocumentSelectionMark extends HasBoundingPolygon {\n  /** State of the selection mark. */\n  state: SelectionMarkState;\n  /** Location of the selection mark in the reading order concatenated content. */\n  span: DocumentSpan;\n  /** Confidence of correctly extracting the selection mark. */\n  confidence: number;\n}\n\n/** A content line object consisting of an adjacent sequence of content elements, such as words and selection marks. */\nexport interface DocumentLine extends HasBoundingPolygon {\n  /** Concatenated content of the contained elements in reading order. */\n  content: string;\n  /** Location of the line in the reading order concatenated content. */\n  spans: DocumentSpan[];\n  /**\n   * Compute the `DocumentWord`s that are related to this line.\n   *\n   * This function produces a lazy iterator that will yield one word before computing the next.\n   */\n  words: () => IterableIterator<DocumentWord>;\n}\n\n/** A paragraph object consisting with contiguous lines generally with common alignment and spacing. */\nexport interface DocumentParagraph {\n  /** Semantic role of the paragraph. */\n  role?: ParagraphRole;\n  /** Concatenated content of the paragraph in reading order. */\n  content: string;\n  /** Bounding regions covering the paragraph. */\n  boundingRegions?: BoundingRegion[];\n  /** Location of the paragraph in the reading order concatenated content. */\n  spans: DocumentSpan[];\n}\n\n/** A table object consisting table cells arranged in a rectangular layout. */\nexport interface DocumentTable {\n  /** Number of rows in the table. */\n  rowCount: number;\n  /** Number of columns in the table. */\n  columnCount: number;\n  /** Cells contained within the table. */\n  cells: DocumentTableCell[];\n  /** Bounding regions covering the table. */\n  boundingRegions?: BoundingRegion[];\n  /** Location of the table in the reading order concatenated content. */\n  spans: DocumentSpan[];\n}\n\n/** An object representing the location and content of a table cell. */\nexport interface DocumentTableCell {\n  /** Table cell kind. */\n  kind?: DocumentTableCellKind;\n  /** Row index of the cell. */\n  rowIndex: number;\n  /** Column index of the cell. */\n  columnIndex: number;\n  /** Number of rows spanned by this cell. */\n  rowSpan?: number;\n  /** Number of columns spanned by this cell. */\n  columnSpan?: number;\n  /** Concatenated content of the table cell in reading order. */\n  content: string;\n  /** Bounding regions covering the table cell. */\n  boundingRegions?: BoundingRegion[];\n  /** Location of the table cell in the reading order concatenated content. */\n  spans: DocumentSpan[];\n}\n\n/** An object representing the location and content of a table caption. */\nexport interface DocumentCaption {\n  /** Table caption content. */\n  content: string;\n  /** Bounding regions covering the table caption. */\n  boundingRegions?: BoundingRegion[];\n  /** Location of the table caption in the reading order concatenated content. */\n  spans: DocumentSpan[];\n}\n\n/** An object representing the location and content of a table footnote. */\nexport interface DocumentFootnote {\n  /** Table footnote content. */\n  content: string;\n  /** Bounding regions covering the table footnote. */\n  boundingRegions?: BoundingRegion[];\n  /** Location of the table footnote in the reading order concatenated content. */\n  spans: DocumentSpan[];\n}\n\n/** An object representing the field key or value in a key-value pair. */\nexport interface DocumentKeyValueElement {\n  /** Concatenated content of the key-value element in reading order. */\n  content: string;\n  /** Bounding regions covering the key-value element. */\n  boundingRegions?: BoundingRegion[];\n  /** Location of the key-value element in the reading order concatenated content. */\n  spans: DocumentSpan[];\n}\n\n/** An object describing the location and semantic content of a document. */\nexport interface Document {\n  /** Document type. */\n  docType: string;\n  /** Bounding regions covering the document. */\n  boundingRegions?: BoundingRegion[];\n  /** Location of the document in the reading order concatenated content. */\n  spans: DocumentSpan[];\n  /** Dictionary of named field values. */\n  fields?: { [propertyName: string]: GeneratedDocumentField };\n  /** Confidence of correctly extracting the document. */\n  confidence: number;\n}\n\n/** An object representing a form field with distinct field label (key) and field value (may be empty). */\nexport interface DocumentKeyValuePair {\n  /** Field label of the key-value pair. */\n  key: DocumentKeyValueElement;\n  /** Field value of the key-value pair. */\n  value?: DocumentKeyValueElement;\n\n  /** Confidence of correctly extracting the key-value pair. */\n  confidence: number;\n}\n\n/**\n * A visual annotation element in the document, such as a check mark or cross.\n */\nexport interface DocumentAnnotation extends HasBoundingPolygon {\n  /** Confidence of correctly extracting the annotation. */\n  confidence: number;\n}\n\n/**\n * An extracted barcode.\n */\nexport interface DocumentBarcode extends HasBoundingPolygon {\n  /**\n   * The type of barcode that was extracted. See the `DocumentBarcodeKind` type for a list of possible values.\n   */\n  kind: DocumentBarcodeKind;\n  /** The encoded data in the barcode. */\n  value: string;\n\n  /** The location of the barcode in the reading-order concatenated `content`. */\n  span: DocumentSpan;\n\n  /** Confidence of correctly extracting the barcode. */\n  confidence: number;\n}\n\n/**\n * An extracted formula.\n */\nexport interface DocumentFormula extends HasBoundingPolygon {\n  /**\n   * The type of formula that was extracted. One of:\n   * - \"inline\": a formula embedded in the content of a paragraph.\n   * - \"display\": a formula in display mode that takes up a whole line.\n   */\n  kind: DocumentFormulaKind;\n\n  /** A LaTeX expression describing the formula. */\n  value: string;\n\n  /** Location of the formula in the reading-order concatenated content. */\n  span: DocumentSpan;\n\n  /** Confidence of correctly extracting the formula. */\n  confidence: number;\n}\n\n/** Content and layout elements extracted from a page from the input. */\nexport interface DocumentPage {\n  /** 1-based page number in the input document. */\n  pageNumber: number;\n  /** The general orientation of the content in clockwise direction, measured in degrees between (-180, 180]. */\n  angle?: number;\n  /** The width of the image/PDF in pixels/inches, respectively. */\n  width?: number;\n  /** The height of the image/PDF in pixels/inches, respectively. */\n  height?: number;\n  /** The unit used by the width, height, and polygon properties. For images, the unit is \"pixel\". PDF, the unit is \"inch\". */\n  unit?: LengthUnit;\n  /** Location of the page in the reading order concatenated content. */\n  spans: DocumentSpan[];\n  /** Extracted words from the page. */\n  words?: DocumentWord[];\n  /** Extracted selection marks from the page. */\n  selectionMarks?: DocumentSelectionMark[];\n  /** Extracted lines from the page, potentially containing both textual and visual elements. */\n  lines?: DocumentLine[];\n\n  /**\n   * Extracted barcodes from the page.\n   */\n  barcodes?: DocumentBarcode[];\n\n  /**\n   * Extracted formulas from the page.\n   *\n   * The `\"formulas\"` feature must be enabled or this property will be undefined.\n   *\n   * See {@link AnalyzeDocumentOptions#features}.\n   */\n  formulas?: DocumentFormula[];\n}\n"]}