// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { EOL } from "node:os";
import { defaultResultFields, getFeatures } from "./defaultFields.js";
import { camelCase, capitalize, uncapitalize } from "./utils.js";
// NOTE: currently, this command is set up to generate sample files for the SDK itself. If we want to expose this
// functionality outside of samples, then we'll need to change the way the headers are generated for external use.
/**
 * The header to append to the top of every file.
 */
const sampleHeader = `
/**
 * @azsdk-util
 * @azsdk-skip-javascript
 */
`;
/**
 * Generate a header with the model information.
 */
function templateHeader(model, test) {
    return `// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
${!test ? sampleHeader : ""}
// Model:       ${model.modelId}
// Description: ${model.description}
// API Version: ${model.apiVersion}
// Created:     ${new Date().toDateString()}

`;
}
/**
 * Generate a TypeScript source file for a given model.
 *
 * @param model - the ModelInfo to generate code for
 * @returns a string of TypeScript source code
 */
export async function writeModelCode(model, test) {
    let contents = templateHeader(model, test);
    if (test) {
        contents += 'import * as fr from "../../../src";' + EOL + EOL;
    }
    else {
        contents += 'import * as fr from "@azure/ai-form-recognizer";' + EOL + EOL;
    }
    const modelNameSlug = [
        ...model.modelId
            .split("-", 2)
            // for lack of a flatMap
            .reduce((acc, cur) => [...acc, ...cur.split(".")], []),
    ];
    const modelName = camelCase([...modelNameSlug, "Model"]);
    const documentTypeName = camelCase([...modelNameSlug, "Document"]);
    const resultName = camelCase([...modelNameSlug, "Result"]);
    const modelFeatures = getFeatures(model);
    const hasDocuments = modelFeatures.some((f) => f === "_documents");
    if (model.description) {
        contents += "/**" + EOL;
        contents +=
            model.description
                // Split the comment into lines.
                .split(/\r?\n/)
                // Add the asterisk to the beginning of each line to block-align the comment
                .map((l) => " * " + l)
                .join(EOL) + EOL;
        contents += " */" + EOL;
    }
    // Create the exported model object. We rely on a function named `modelInfo` to exist in the module scope, and we will
    // add it later.
    contents += `export const ${modelName} = fr.createModelFromSchema(modelInfo()) as fr.DocumentModel<${resultName}>;${EOL + EOL}`;
    // Write the main Result interface.
    for (const line of writeResultInterface(resultName, documentTypeName, modelFeatures)) {
        contents += line + EOL;
    }
    contents += EOL;
    // Now add a variant for each document type in the model, if there are any.
    if (hasDocuments) {
        const variants = extractModelVariants(model, modelNameSlug);
        const variantNames = Object.keys(variants);
        const documentType = variantNames.length > 1
            ? // In the case of multiple variants, a union
                variantNames.map((n) => `${EOL}  | ${n}`).join("")
            : variantNames.length === 1
                ? // For a single variant, just emit its name.
                    ` ${variantNames[0]}`
                : // This should probably be unreachable, since there's no case where
                    // `hasDocuments && variantNames.length === 0`, but we'll still emit "never" just in case.
                    " never";
        // Finally, add the type alias for the type of a Document
        contents += `export type ${documentTypeName} =${documentType};${EOL + EOL}`;
        // Write the root interface for the variant.
        for (const info of Object.values(variants)) {
            for (const line of writeDocTypeInterface(info)) {
                contents += line + EOL;
            }
            contents += EOL;
        }
        // Write all the fields interfaces that the variant uses
        for (const info of Object.values(variants)) {
            for (const line of writeFieldsInterfaces(info)) {
                contents += line + EOL;
            }
            contents += EOL;
        }
    }
    // Finally, emit the modelInfo function that provides the raw schema.
    contents += "/**" + EOL;
    contents += " * The raw model schema." + EOL;
    contents += " */" + EOL;
    contents += "function modelInfo() {" + EOL;
    contents +=
        `  return ${JSON.stringify(model, null, 2)
            .split(/\r?\n/)
            .join(EOL + "  ")} as const;` + EOL;
    contents += "}" + EOL;
    return contents;
}
// Get the doc type variants of a model.
function extractModelVariants(model, _rootSlug) {
    var _a;
    const result = {};
    for (const [docType, info] of Object.entries((_a = model.docTypes) !== null && _a !== void 0 ? _a : {})) {
        const slug = docType.split(".");
        const docTypeName = camelCase(slug);
        result[docTypeName] = Object.assign(Object.assign({}, info), { name: docTypeName, originalDocType: docType, slug });
    }
    return result;
}
// Write the interface for a given DocType.
function* writeDocTypeInterface(docType) {
    if (docType.description) {
        yield "/**";
        yield* docType.description.split(/\r?\n/).map((l) => " * " + l);
        yield " */";
    }
    yield `export interface ${docType.name} {`;
    yield* indent(writeField({
        name: "docType",
        type: `"${docType.originalDocType}"`,
        docContents: `Document type: "${docType.originalDocType}".`,
    }));
    yield* indent(writeField({
        name: "fields",
        type: docType.name + "Fields",
        docContents: "Document fields.",
    }));
    yield* indent(flatMap([
        {
            name: "boundingRegions",
            docContents: "Bounding regions covering the document.",
            type: "fr.BoundingRegion[]",
            optional: true,
        },
        {
            name: "spans",
            docContents: "Locations of the document's elements in the `content` text (reading-order-concatenated content).",
            type: "fr.DocumentSpan[]",
        },
        {
            name: "confidence",
            docContents: "The service's confidence that it has correctly extracted the document.",
            type: "number",
        },
    ], writeField));
    yield "}";
}
/**
 * Write a field and its comment to an iterable of strings.
 */
function* writeField(field) {
    yield "/**";
    yield* field.docContents.split(/\r?\n/).map((line) => ` * ${line}`);
    yield " */";
    // If the field name has an illegal character, we need to quote it.
    const needsQuotes = !/^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(field.name);
    const printedFieldName = needsQuotes ? `"${field.name}"` : field.name;
    yield `${printedFieldName}${field.optional ? "?" : ""}: ${field.type};`;
}
/**
 * Recursively write the fields interfaces for a given document type.
 */
function* writeFieldsInterfaces(docType) {
    const name = docType.name + "Fields";
    yield* writeInterfaceDeclaration(name, docType.description, docType.fieldSchema);
    // Recursively visit all child interfaces and write them.
    yield* (function* collectNestedInterfaces(fields, namingContext) {
        var _a, _b, _c, _d, _e, _f, _g;
        for (const [fieldName, schema] of Object.entries(fields)) {
            if (schema.type === "array" && ((_a = schema.items) === null || _a === void 0 ? void 0 : _a.type) === "object") {
                // Generate element interface and recur if the nested type is an object
                const nextNamingContext = namingContext + fieldName + "Element";
                yield "";
                yield "";
                yield* writeInterfaceDeclaration(nextNamingContext, schema.description, (_c = (_b = schema.items) === null || _b === void 0 ? void 0 : _b.properties) !== null && _c !== void 0 ? _c : {});
                yield* collectNestedInterfaces((_e = (_d = schema.items) === null || _d === void 0 ? void 0 : _d.properties) !== null && _e !== void 0 ? _e : {}, nextNamingContext);
            }
            else if (schema.type === "object") {
                // Generate named interface and recur
                yield "";
                yield "";
                yield* writeInterfaceDeclaration(namingContext + fieldName, schema.description, (_f = schema.properties) !== null && _f !== void 0 ? _f : {});
                yield* collectNestedInterfaces((_g = schema.properties) !== null && _g !== void 0 ? _g : {}, namingContext + fieldName);
            }
        }
    })(docType.fieldSchema, docType.name);
    /**
     * Write a simple interface declaration.
     *
     * @param interfaceName - the symbolic name of the interface
     * @param description - the interface's documentation string.
     * @param fields - the fields of the interface (a map of names to schemas)
     */
    function* writeInterfaceDeclaration(interfaceName, description, fields) {
        yield "/**";
        yield ` * Describes the fields of \`${interfaceName}\`.`;
        if (description) {
            yield " * ";
            yield* description.split(/\r?\n/).map((l) => " * " + l);
        }
        yield " */";
        const prefix = `export interface ${interfaceName} {`;
        const suffix = "}";
        const fieldEntries = Object.entries(fields);
        if (fieldEntries.length === 0) {
            yield prefix + suffix;
        }
        else {
            yield prefix;
            yield* indent(flatMap(fieldEntries.map(([fieldName, schema]) => {
                var _a;
                return ({
                    // Uncapitalize the field name and remove all whitespace
                    name: uncapitalize(fieldName).replace(/\s/g, ""),
                    type: writeType(schema, fieldName, docType.slug),
                    docContents: (_a = schema.description) !== null && _a !== void 0 ? _a : `\`${docType.name}\` "${fieldName}" field`,
                    optional: true,
                });
            }), writeField));
            yield suffix;
        }
    }
}
/**
 * Generate a type name for a field schema.
 *
 * @param schema - the schema of the type
 * @param name - the name to append to the field type, if necessary (only applies to objects and arrays)
 * @param slug - the current taxonomic naming context of the field name (used to name object types)
 * @returns a string representing the type name for the field
 */
function writeType(schema, name, slug) {
    const kind = schema.type;
    if (kind === "array") {
        return `fr.DocumentArrayField<${writeType(schema.items, "Element", [...slug, name])}>`;
    }
    else if (kind === "object") {
        const propertiesName = slug.map(capitalize).join("") + name;
        return `fr.DocumentObjectField<${propertiesName}>`;
    }
    else {
        return {
            integer: "fr.DocumentIntegerField",
            string: "fr.DocumentStringField",
            countryRegion: "fr.DocumentCountryRegionField",
            currency: "fr.DocumentCurrencyField",
            time: "fr.DocumentTimeField",
            date: "fr.DocumentDateField",
            number: "fr.DocumentNumberField",
            boolean: "fr.DocumentBooleanField",
            phoneNumber: "fr.DocumentPhoneNumberField",
            selectionMark: "fr.DocumentSelectionMarkField",
            signature: "fr.DocumentSignatureField",
            address: "fr.DocumentAddressField",
        }[kind];
    }
}
/**
 * Generate an AnalyzeResult-level interface.
 *
 * @param name - the name of the interface.
 * @param documentInterfaceName - the name of the interface's document type.
 * @param features - the features supported by the model
 */
function* writeResultInterface(name, documentInterfaceName, features) {
    const hasDocuments = features.some((f) => f === "_documents");
    yield `export interface ${name} extends fr.AnalyzeResultCommon {`;
    yield* indent(flatMap(features.filter((f) => f !== "_documents"), (f) => writeField(defaultResultFields[f])));
    if (hasDocuments) {
        yield* indent(writeField({
            name: "documents",
            type: documentInterfaceName + "[]",
            docContents: "Extracted documents.",
        }));
    }
    yield "}";
}
/**
 * A helper function to indent an iterable.
 */
function* indent(contents, level = 2) {
    const indentationString = " ".repeat(level);
    for (const line of contents) {
        yield indentationString + line;
    }
}
/**
 * A `flatMap` helper that works with generic iterables, not only arrays. If the result of `f` is iterable, its elements
 * will be produced instead of itself.
 *
 * @param it - the iterable to map over
 * @param f - the function to apply to each item in `it`
 */
function* flatMap(it, f) {
    for (const value of it) {
        const result = f(value);
        if (typeof result === "object" && result !== null && Symbol.iterator in result) {
            yield* result;
        }
        else {
            yield result;
        }
    }
}
//# sourceMappingURL=writeModelCode.js.map