{"version":3,"file":"analysis.js","sourceRoot":"","sources":["../../../src/lro/analysis.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { PollOperationState, PollerLike } from \"@azure/core-lro\";\nimport { FormRecognizerError } from \"../error.js\";\nimport type {\n  AnalyzeResult as GeneratedAnalyzeResult,\n  AnalyzeResultOperation,\n  AnalyzeResultOperationStatus as AnalyzeOperationStatus,\n  DocumentLanguage,\n  DocumentSpan,\n  DocumentStyle,\n} from \"../generated/index.js\";\nimport type { DocumentField } from \"../models/fields.js\";\nimport { toAnalyzedDocumentFieldsFromGenerated } from \"../models/fields.js\";\nimport type { PollerOptions } from \"../options/index.js\";\nimport type { AnalyzeDocumentOptions } from \"../options/AnalyzeDocumentOptions.js\";\nimport {\n  toBoundingPolygon,\n  toBoundingRegions,\n  toDocumentTableFromGenerated,\n  toKeyValuePairFromGenerated,\n} from \"../transforms/polygon.js\";\nimport type {\n  BoundingRegion,\n  DocumentTable,\n  DocumentKeyValuePair,\n  DocumentPage,\n  DocumentLine,\n  DocumentParagraph,\n  DocumentFormula,\n} from \"../models/documentElements.js\";\nimport type {\n  Document as GeneratedDocument,\n  DocumentPage as GeneratedDocumentPage,\n  DocumentLine as GeneratedDocumentLine,\n} from \"../generated/index.js\";\n\n/**\n * A request input that can be uploaded as binary data to the Form Recognizer service. Form Recognizer treats `string`\n * inputs as URLs, so to send a string as a _binary_ input, first convert the string to one of the following input\n * types.\n */\nexport type FormRecognizerRequestBody =\n  | NodeJS.ReadableStream\n  | Blob\n  | ArrayBuffer\n  | ArrayBufferView;\n\n/**\n * An extracted document object.\n *\n * An AnalyzedDocument is an instance of one of the document types within a model. Its fields correspond to the field\n * schema of the document type.\n */\nexport interface AnalyzedDocument {\n  /**\n   * The type of the document that was extracted. A model can have multiple document types (for example, in a composed\n   * model), so this property indicates which document type the fields of this document correspond to.\n   */\n  docType: string;\n\n  /**\n   * The extracted fields, which correspond to the document type's field schema.\n   */\n  fields: { [field: string]: DocumentField };\n\n  /**\n   * Bounding regions covering the document.\n   */\n  boundingRegions?: BoundingRegion[];\n\n  /**\n   * Locations of the document's elements in the `content` text (reading-order-concatenated content).\n   */\n  spans: DocumentSpan[];\n\n  /**\n   * The service's confidence that it has correctly extracted the document.\n   */\n  confidence: number;\n}\n\n/**\n * Transform a REST-level Document response object into the more strongly-typed AnalyzedDocument.\n *\n * @internal\n * @param document - a REST-level document response object\n * @returns an AnalyzedDocument (which has had its fields mapped to stronger DocumentField types)\n */\nexport function toAnalyzedDocumentFromGenerated(document: GeneratedDocument): AnalyzedDocument {\n  return {\n    ...document,\n    boundingRegions: toBoundingRegions(document.boundingRegions),\n    fields: toAnalyzedDocumentFieldsFromGenerated(document.fields ?? {}),\n  };\n}\n\n/**\n * The common fields of all AnalyzeResult-like types, such as LayoutResult, ReadResult, and GeneralDocumentResult.\n */\nexport interface AnalyzeResultCommon {\n  /**\n   * The service API version used to produce this result.\n   */\n  apiVersion: string;\n\n  /**\n   * The unique ID of the model that was used to produce this result.\n   */\n  modelId: string;\n\n  /**\n   * A string representation of all textual and visual elements in the input, concatenated by reading order (the order\n   * in which the service \"reads\" or extracts the textual and visual content from the document).\n   */\n  content: string;\n}\n\n/**\n * The result of an analysis operation. The type of the Document may be determined by the model used to perform the\n * analysis.\n */\nexport interface AnalyzeResult<Document = AnalyzedDocument> extends AnalyzeResultCommon {\n  /**\n   * Extracted pages.\n   */\n  pages?: DocumentPage[];\n\n  /**\n   * Extracted tables.\n   */\n  tables?: DocumentTable[];\n\n  /**\n   * Extracted key-value pairs.\n   */\n  keyValuePairs?: DocumentKeyValuePair[];\n\n  /**\n   * Extracted text languages.\n   */\n  languages?: DocumentLanguage[];\n\n  /**\n   * Extracted font styles.\n   */\n  styles?: DocumentStyle[];\n\n  /**\n   * Extracted documents (instances of any of the model's document types and corresponding field schemas).\n   */\n  documents?: Document[];\n\n  /**\n   * Extracted document paragraphs.\n   */\n  paragraphs?: DocumentParagraph[];\n}\n\n/**\n * Tests if one span contains another, by testing that the outer span starts before or at the same character as the\n * inner span, and that the end position of the outer span is greater than or equal to the end position of the inner\n * span.\n *\n * @internal\n * @param outer - the outer (potentially containing) span\n * @param inner - the span to test if `outer` contains\n * @returns true if `inner` is contained inside of `outer`.\n */\nexport function contains(outer: DocumentSpan, inner: DocumentSpan): boolean {\n  return outer.offset <= inner.offset && outer.offset + outer.length >= inner.offset + inner.length;\n}\n\n/**\n * Make an empty generator. This might seem silly, but it's useful for satisfying invariants.\n */\nfunction* empty(): Generator<never> {\n  /* intentionally empty */\n}\n\n/**\n * Produces an iterator of the given items starting from the given index.\n *\n * @param items - the items to iterate over\n * @param idx - the index of the first item to begin iterating from\n */\nexport function* iterFrom<T>(items: T[], idx: number): Generator<T> {\n  let i = idx;\n\n  while (i < items.length) {\n    yield items[i++];\n  }\n}\n\nexport function toDocumentLineFromGenerated(\n  generated: GeneratedDocumentLine,\n  page: GeneratedDocumentPage,\n): DocumentLine {\n  (generated as DocumentLine).words = () =>\n    fastGetChildren(\n      iterFrom(generated.spans, 0),\n      page.words?.map((word) => {\n        return { ...word, polygon: toBoundingPolygon(word.polygon) };\n      }) ?? [],\n    );\n\n  (generated as DocumentLine).polygon = toBoundingPolygon(generated.polygon);\n\n  Object.defineProperty(generated, \"words\", {\n    enumerable: false,\n  });\n\n  return generated as DocumentLine;\n}\n\nexport function toDocumentPageFromGenerated(generated: GeneratedDocumentPage): DocumentPage {\n  return {\n    ...generated,\n    lines: generated.lines?.map((line) => toDocumentLineFromGenerated(line, generated)),\n    selectionMarks: generated.selectionMarks?.map((mark) => ({\n      ...mark,\n      polygon: toBoundingPolygon(mark.polygon),\n    })),\n    words: generated.words?.map((word) => ({\n      ...word,\n      polygon: toBoundingPolygon(word.polygon),\n    })),\n    barcodes: generated.barcodes?.map((barcode) => ({\n      ...barcode,\n      polygon: toBoundingPolygon(barcode.polygon),\n    })),\n    formulas: generated.formulas?.map(\n      (formula): DocumentFormula => ({\n        ...formula,\n        polygon: toBoundingPolygon(formula.polygon),\n      }),\n    ),\n  };\n}\n\n/**\n * Binary search through an array of items to find the first item that could possibly be contained by the given span,\n * then return an iterator beginning from that item.\n *\n * This allows a program to quickly find the first relevant item in the array for consideration when testing for span\n * inclusion.\n *\n * @internal\n * @param span - the span to use when testing each individual item\n * @param items - an array of items to binary search through\n * @returns an iterator beginning from the item identified by the search\n */\nexport function iteratorFromFirstMatchBinarySearch<Spanned extends { span: DocumentSpan }>(\n  span: DocumentSpan,\n  items: Spanned[],\n): IterableIterator<Spanned> {\n  let idx = Math.floor(items.length / 2);\n  let prevIdx = idx;\n  let min = 0;\n  let max = items.length;\n\n  const found = (): boolean =>\n    // The item is found if it starts after the current span and the item before it does not. That means it is the first\n    // item in the array that could be a child if the spans are sorted.\n    items[idx].span.offset >= span.offset && (items[idx - 1]?.span?.offset ?? -1) < span.offset;\n\n  // Binary search to find the first element that could be a child\n  do {\n    if (found()) {\n      return iterFrom(items, idx);\n    } else if (span.offset > items[idx].span.offset) {\n      min = prevIdx = idx;\n      idx = Math.floor(idx + (max - idx) / 2);\n    } else {\n      max = prevIdx = idx;\n      idx = Math.floor(idx - (idx - min) / 2);\n    }\n  } while (idx !== prevIdx);\n\n  // This might seem weird, but it's a simple way to make the types a little more elegant.\n  return empty();\n}\n\n/**\n * This fast algorithm tests the elements of `childArray` for inclusion in any of the given `spans`, assuming that both\n * the spans and child items are sorted.\n *\n * INVARIANT: the items in both the `spans` iterator and `childrenArray` MUST BE SORTED INCREASING by span _offset_.\n *\n * @internal\n * @param spans - the spans that contain the child elements\n * @param childrenArray - an array of child items (items that have spans) to test for inclusion in the spans\n * @returns - an IterableIterator of child items that are included in any span in the `spans` iterator\n */\nexport function* fastGetChildren<Spanned extends { span: DocumentSpan }>(\n  spans: Iterator<DocumentSpan>,\n  childrenArray: Spanned[],\n): Generator<Spanned> {\n  let curSpan = spans.next();\n\n  // Need to exit early if there are no spans.\n  if (curSpan.done) {\n    return;\n  }\n\n  const children = iteratorFromFirstMatchBinarySearch(curSpan.value as DocumentSpan, childrenArray);\n  let curChild = children.next();\n\n  while (!(curChild.done || curSpan.done)) {\n    if (contains(curSpan.value, curChild.value.span)) {\n      // The span is contained, so yield the current child and advance it.\n      yield curChild.value;\n      curChild = children.next();\n    } else if (curSpan.value.offset + curSpan.value.length < curChild.value.span.offset) {\n      // The current span ends before the next potential child starts, so advance the span\n      curSpan = spans.next();\n    } else {\n      // The current child was not contained in the current span, so advance to the next child.\n      curChild = children.next();\n    }\n  }\n}\n\n/**\n * The state of an analysis operation, which will eventually produce the result type that corresponds to the model.\n */\nexport interface DocumentAnalysisPollOperationState<Result = AnalyzeResult<AnalyzedDocument>>\n  extends PollOperationState<Result> {\n  /**\n   * The status of the operation. One of:\n   *\n   * - \"notStarted\"\n   * - \"running\"\n   * - \"succeeded\"\n   * - \"failed\"\n   */\n  status: AnalyzeOperationStatus;\n\n  /**\n   * The model ID that the analysis operation will use to produce the result.\n   */\n  modelId: string;\n\n  /**\n   * The URL to the operation.\n   */\n  operationLocation: string;\n\n  /**\n   * The Date and Time that the operation was created.\n   */\n  createdOn: Date;\n\n  /**\n   * The date & time that the operation state was last modified.\n   */\n  lastUpdatedOn: Date;\n}\n\n/**\n * A long-running operation (poller) that tracks the state of an analysis operation, eventually producing the result\n * type that corresponds to the model.\n */\nexport type AnalysisPoller<Result = AnalyzeResult<AnalyzedDocument>> = PollerLike<\n  DocumentAnalysisPollOperationState<Result>,\n  Result\n>;\n\n/**\n * Convert a generated AnalyzeResult into a convenience layer AnalyzeResult.\n * @internal\n */\nexport function toAnalyzeResultFromGenerated(result: GeneratedAnalyzeResult): AnalyzeResult {\n  return {\n    apiVersion: result.apiVersion,\n    modelId: result.modelId,\n    content: result.content,\n    pages: result.pages.map((page) => toDocumentPageFromGenerated(page)),\n    tables: result.tables?.map((table) => toDocumentTableFromGenerated(table)),\n    keyValuePairs: result.keyValuePairs?.map((pair) => toKeyValuePairFromGenerated(pair)),\n    languages: result.languages,\n    styles: result.styles,\n    paragraphs: result.paragraphs?.map((para) => ({\n      ...para,\n      boundingRegions: toBoundingRegions(para.boundingRegions),\n    })),\n    documents: result.documents?.map(toAnalyzedDocumentFromGenerated),\n  };\n}\n\n/**\n * Defines an analysis operation by the initial request model ID, poller options, and a transform to apply to the\n * eventual result,\n *\n * @internal\n */\nexport interface AnalysisOperationDefinition<Result = AnalyzeResult> {\n  transformResult: (primitiveResult: GeneratedAnalyzeResult) => Result;\n  initialModelId: string;\n  options: PollerOptions<DocumentAnalysisPollOperationState<Result>> &\n    AnalyzeDocumentOptions<Result>;\n}\n\n/**\n * Converts an AnalyzeResultOperation (LRO response) to a DocumentAnalysisPollOperationState\n * @internal\n */\nexport function toDocumentAnalysisPollOperationState<Result>(\n  definition: AnalysisOperationDefinition<Result>,\n  modelId: string,\n  operationLocation: string,\n  response: AnalyzeResultOperation,\n): DocumentAnalysisPollOperationState<Result> {\n  return {\n    status: response.status,\n    modelId: modelId,\n    lastUpdatedOn: response.lastUpdatedOn,\n    createdOn: response.createdOn,\n    operationLocation,\n    result: response.analyzeResult && definition.transformResult(response.analyzeResult),\n    error: response.error && new FormRecognizerError(response.error),\n    isCancelled: false, // Not supported\n    isStarted: response.status !== \"notStarted\",\n    isCompleted: response.status === \"succeeded\",\n  };\n}\n"]}