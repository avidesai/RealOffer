{"version":3,"file":"polygon.js","sourceRoot":"","sources":["../../../src/transforms/polygon.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AA2BlC,MAAM,UAAU,iBAAiB,CAAC,QAA8B;IAC9D,MAAM,MAAM,GAAc,EAAE,CAAC;IAC7B,IAAI,CAAC,QAAQ;QAAE,OAAO;IAEtB,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC;QAC9B,MAAM,IAAI,KAAK,CACb,+EAA+E,CAChF,CAAC;IACJ,CAAC;IAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;QAC5C,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;IACtD,CAAC;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,MAAM,UAAU,iBAAiB,CAC/B,QAA+C;IAE/C,OAAO,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAE,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,iCAAM,MAAM,KAAE,OAAO,EAAE,iBAAiB,CAAC,MAAM,CAAC,OAAO,CAAC,IAAG,CAAC,CAAC;AAChG,CAAC;AAED,MAAM,UAAU,4BAA4B,CAAC,KAA6B;IACxE,uCACK,KAAK,KACR,eAAe,EAAE,iBAAiB,CAAC,KAAK,CAAC,eAAe,CAAC,EACzD,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,iCAC5B,IAAI,KACP,eAAe,EAAE,iBAAiB,CAAC,IAAI,CAAC,eAAe,CAAC,IACxD,CAAC,IACH;AACJ,CAAC;AAED,MAAM,UAAU,2BAA2B,CACzC,IAAmC;;IAEnC,uCACK,IAAI,KACP,GAAG,kCAAO,IAAI,CAAC,GAAG,KAAE,eAAe,EAAE,iBAAiB,CAAC,IAAI,CAAC,GAAG,CAAC,eAAe,CAAC,KAChF,KAAK,EAAE,IAAI,CAAC,KAAK;YACf,CAAC,iCAAM,IAAI,CAAC,KAAK,KAAE,eAAe,EAAE,iBAAiB,CAAC,MAAA,IAAI,CAAC,KAAK,0CAAE,eAAe,CAAC,IAClF,CAAC,CAAC,SAAS,IACb;AACJ,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type {\n  BoundingRegion as GeneratedBoundingRegion,\n  DocumentKeyValuePair as GeneratedDocumentKeyValuePair,\n  DocumentTable as GeneratedDocumentTable,\n} from \"../generated/index.js\";\nimport type {\n  BoundingRegion,\n  DocumentKeyValuePair,\n  DocumentTable,\n} from \"../models/documentElements.js\";\n\n/**\n * Represents a point used to define bounding polygons. The unit is either 'pixel' or 'inch' (See {@link LengthUnit}).\n */\nexport interface Point2D {\n  /**\n   * x coordinate - relative from the left side of the page\n   */\n  x: number;\n  /**\n   * y coordinate - relative from the top of the page\n   */\n  y: number;\n}\n\nexport function toBoundingPolygon(original: number[] | undefined): Point2D[] | undefined {\n  const points: Point2D[] = [];\n  if (!original) return;\n\n  if (original.length % 2 !== 0) {\n    throw new Error(\n      \"Unexpected number of points in the response, unable to translate as 2D points\",\n    );\n  }\n\n  for (let i = 0; i < original.length; i += 2) {\n    points.push({ x: original[i], y: original[i + 1] });\n  }\n\n  return points;\n}\n\nexport function toBoundingRegions(\n  original: GeneratedBoundingRegion[] | undefined,\n): BoundingRegion[] | undefined {\n  return original?.map((region) => ({ ...region, polygon: toBoundingPolygon(region.polygon) }));\n}\n\nexport function toDocumentTableFromGenerated(table: GeneratedDocumentTable): DocumentTable {\n  return {\n    ...table,\n    boundingRegions: toBoundingRegions(table.boundingRegions),\n    cells: table.cells.map((cell) => ({\n      ...cell,\n      boundingRegions: toBoundingRegions(cell.boundingRegions),\n    })),\n  };\n}\n\nexport function toKeyValuePairFromGenerated(\n  pair: GeneratedDocumentKeyValuePair,\n): DocumentKeyValuePair {\n  return {\n    ...pair,\n    key: { ...pair.key, boundingRegions: toBoundingRegions(pair.key.boundingRegions) },\n    value: pair.value\n      ? { ...pair.value, boundingRegions: toBoundingRegions(pair.value?.boundingRegions) }\n      : undefined,\n  };\n}\n"]}