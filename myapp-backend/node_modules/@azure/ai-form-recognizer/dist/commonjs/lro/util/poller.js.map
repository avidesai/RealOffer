{"version":3,"file":"poller.js","sourceRoot":"","sources":["../../../../src/lro/util/poller.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { PollOperationState, PollerLike } from \"@azure/core-lro\";\nimport { delayMs } from \"./delayMs.js\";\nimport type { AbortSignalLike } from \"@azure/abort-controller\";\nimport { AbortError } from \"@azure/abort-controller\";\n\nconst DEFAULT_POLLING_INTERVAL = 5000;\n\n/**\n * Information about the Long-Running Operation (LRO) that is being performed.\n */\nexport interface OperationContext {\n  /**\n   * An AbortSignal that can be used to cancel the operation.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * Sets the server's preferred polling interval in milliseconds. To clear the server's preferred polling interval,\n   * pass `undefined`.\n   */\n  updateDelay: (interval: number | undefined) => void;\n}\n\n/**\n * A specification for a long-running operation, which defines the poller flow.\n * @internal\n */\nexport interface OperationSpec<TState extends PollOperationState<unknown>> {\n  /**\n   * A function that produces the first operation state for this LRO.\n   */\n  init: (ctx: OperationContext) => Promise<TState>;\n  /**\n   * A function that consumes the existing state of the poller and produces the next state.\n   */\n  poll: (ctx: OperationContext, state: TState) => Promise<TState>;\n  /**\n   * A function that serializes the state into a string.\n   */\n  serialize: (state: TState) => string;\n}\n\n/**\n * Uniform poller implementation, creates a poller based on a PollerSpec.\n *\n * @internal\n */\nexport async function lro<TResult, TState extends PollOperationState<TResult>>(\n  spec: OperationSpec<TState>,\n  pollingInterval: number | undefined,\n  initAbortSignal: AbortSignalLike | undefined,\n): Promise<PollerLike<TState, TResult>> {\n  let serverDrivenDelay: number | undefined;\n\n  const initContext: OperationContext = {\n    abortSignal: initAbortSignal,\n    updateDelay: (interval) => {\n      serverDrivenDelay = interval;\n    },\n  };\n\n  if (initAbortSignal?.aborted) {\n    throw new AbortError(\"The operation was aborted.\");\n  }\n\n  let state = await spec.init(initContext);\n\n  type ThisPoller = PollerLike<TState, TResult>;\n\n  // Job handling. If `job` is defined, then there is an active `pollUntilDone` call on this poller.\n  // Call `cancelJob` to interrupt the polling loop (awaiters will throw).\n  let job: Promise<TResult> | undefined;\n  let cancelJob: (() => void) | undefined;\n\n  // Progress handlers\n  type Handler = (state: TState) => void;\n  const handlers = new Map<symbol, Handler>();\n  const handleProgressEvents = async (): Promise<void> => handlers.forEach((h) => h(state));\n\n  const self: ThisPoller = {\n    onProgress: (callback: (state: TState) => void) => {\n      const s = Symbol();\n      handlers.set(s, callback);\n      return () => handlers.delete(s);\n    },\n    stopPolling: () => cancelJob?.(),\n    poll: async (options) => {\n      state = await spec.poll(\n        {\n          abortSignal: options?.abortSignal,\n          updateDelay: (interval) => {\n            serverDrivenDelay = interval;\n          },\n        },\n        state,\n      );\n      handleProgressEvents();\n    },\n    pollUntilDone: (options) =>\n      (job ??= (async () => {\n        // Technically, the poller could complete during initialization\n        if (!self.isDone()) {\n          // Poll once to get the ball rolling, this avoids a delay if the operation completes immediately\n          await self.poll(options);\n          while (!self.isDone()) {\n            const finalPollingInterval = Math.max(\n              serverDrivenDelay ?? 0,\n              pollingInterval ?? DEFAULT_POLLING_INTERVAL,\n            );\n            const delay = delayMs(finalPollingInterval, options?.abortSignal);\n            cancelJob = delay.cancel;\n            await delay.then(() => self.poll());\n          }\n        }\n        const result = self.getResult();\n\n        // The state says it's done, so we know we are in either a success case, an error case, or an _internal_ error.\n        if (result !== undefined) return result;\n        else if (state.error !== undefined) throw state.error;\n        // Unreachable\n        else {\n          throw new Error(\n            `Internal Client Error: analysis poller completed without success or error: ${state}`,\n          );\n        }\n      })().finally(() => {\n        job = undefined;\n      })),\n    // The poller is stopped if there is no job running\n    isStopped: () => !!job,\n    // The operation is complete if either a result or error is produced\n    isDone: () => !!state.result || !!state.error,\n    // In FR, all operations run to completion\n    cancelOperation() {\n      throw new Error(\"The Azure Form Recognizer service does not support operation cancellation.\");\n    },\n    getOperationState: () => state,\n    getResult: () => state.result,\n    toString: () => spec.serialize(state),\n  };\n\n  return self;\n}\n"]}