{"version":3,"file":"writeModelCode.js","sourceRoot":"","sources":["../../../src/bin/writeModelCode.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { EOL } from \"node:os\";\nimport type { DocumentTypeDetails, DocumentModelDetails } from \"../index.js\";\nimport type { DocumentFieldSchema } from \"../generated/index.js\";\nimport type { DocumentField } from \"../models/index.js\";\nimport { defaultResultFields, getFeatures } from \"./defaultFields.js\";\nimport type { Field } from \"./utils.js\";\nimport { camelCase, capitalize, uncapitalize } from \"./utils.js\";\n\n// NOTE: currently, this command is set up to generate sample files for the SDK itself. If we want to expose this\n// functionality outside of samples, then we'll need to change the way the headers are generated for external use.\n\n/**\n * The header to append to the top of every file.\n */\nconst sampleHeader = `\n/**\n * @azsdk-util\n * @azsdk-skip-javascript\n */\n`;\n\n/**\n * Generate a header with the model information.\n */\nfunction templateHeader(model: DocumentModelDetails, test: boolean): string {\n  return `// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n${!test ? sampleHeader : \"\"}\n// Model:       ${model.modelId}\n// Description: ${model.description}\n// API Version: ${model.apiVersion}\n// Created:     ${new Date().toDateString()}\n\n`;\n}\n\n/**\n * Generate a TypeScript source file for a given model.\n *\n * @param model - the ModelInfo to generate code for\n * @returns a string of TypeScript source code\n */\nexport async function writeModelCode(model: DocumentModelDetails, test: boolean): Promise<string> {\n  let contents = templateHeader(model, test);\n\n  if (test) {\n    contents += 'import * as fr from \"../../../src\";' + EOL + EOL;\n  } else {\n    contents += 'import * as fr from \"@azure/ai-form-recognizer\";' + EOL + EOL;\n  }\n\n  const modelNameSlug = [\n    ...model.modelId\n      .split(\"-\", 2)\n      // for lack of a flatMap\n      .reduce((acc, cur) => [...acc, ...cur.split(\".\")], [] as string[]),\n  ];\n\n  const modelName = camelCase([...modelNameSlug, \"Model\"]);\n  const documentTypeName = camelCase([...modelNameSlug, \"Document\"]);\n  const resultName = camelCase([...modelNameSlug, \"Result\"]);\n\n  const modelFeatures = getFeatures(model);\n\n  const hasDocuments = modelFeatures.some((f) => f === \"_documents\");\n\n  if (model.description) {\n    contents += \"/**\" + EOL;\n    contents +=\n      model.description\n        // Split the comment into lines.\n        .split(/\\r?\\n/)\n        // Add the asterisk to the beginning of each line to block-align the comment\n        .map((l) => \" * \" + l)\n        .join(EOL) + EOL;\n    contents += \" */\" + EOL;\n  }\n\n  // Create the exported model object. We rely on a function named `modelInfo` to exist in the module scope, and we will\n  // add it later.\n  contents += `export const ${modelName} = fr.createModelFromSchema(modelInfo()) as fr.DocumentModel<${resultName}>;${\n    EOL + EOL\n  }`;\n\n  // Write the main Result interface.\n  for (const line of writeResultInterface(resultName, documentTypeName, modelFeatures)) {\n    contents += line + EOL;\n  }\n\n  contents += EOL;\n\n  // Now add a variant for each document type in the model, if there are any.\n  if (hasDocuments) {\n    const variants = extractModelVariants(model, modelNameSlug);\n\n    const variantNames = Object.keys(variants);\n\n    const documentType =\n      variantNames.length > 1\n        ? // In the case of multiple variants, a union\n          variantNames.map((n) => `${EOL}  | ${n}`).join(\"\")\n        : variantNames.length === 1\n          ? // For a single variant, just emit its name.\n            ` ${variantNames[0]}`\n          : // This should probably be unreachable, since there's no case where\n            // `hasDocuments && variantNames.length === 0`, but we'll still emit \"never\" just in case.\n            \" never\";\n\n    // Finally, add the type alias for the type of a Document\n    contents += `export type ${documentTypeName} =${documentType};${EOL + EOL}`;\n\n    // Write the root interface for the variant.\n    for (const info of Object.values(variants)) {\n      for (const line of writeDocTypeInterface(info)) {\n        contents += line + EOL;\n      }\n\n      contents += EOL;\n    }\n\n    // Write all the fields interfaces that the variant uses\n    for (const info of Object.values(variants)) {\n      for (const line of writeFieldsInterfaces(info)) {\n        contents += line + EOL;\n      }\n\n      contents += EOL;\n    }\n  }\n\n  // Finally, emit the modelInfo function that provides the raw schema.\n  contents += \"/**\" + EOL;\n  contents += \" * The raw model schema.\" + EOL;\n  contents += \" */\" + EOL;\n  contents += \"function modelInfo() {\" + EOL;\n  contents +=\n    `  return ${JSON.stringify(model, null, 2)\n      .split(/\\r?\\n/)\n      .join(EOL + \"  \")} as const;` + EOL;\n  contents += \"}\" + EOL;\n\n  return contents;\n}\n\n// Get the doc type variants of a model.\nfunction extractModelVariants(\n  model: DocumentModelDetails,\n  _rootSlug: string[],\n): Record<string, DocType> {\n  const result: ReturnType<typeof extractModelVariants> = {};\n\n  for (const [docType, info] of Object.entries(model.docTypes ?? {})) {\n    const slug = docType.split(\".\");\n    const docTypeName = camelCase(slug);\n    result[docTypeName] = {\n      ...info,\n      name: docTypeName,\n      originalDocType: docType,\n      slug,\n    };\n  }\n\n  return result;\n}\n\n// Write the interface for a given DocType.\nfunction* writeDocTypeInterface(docType: DocType): Iterable<string> {\n  if (docType.description) {\n    yield \"/**\";\n    yield* docType.description.split(/\\r?\\n/).map((l) => \" * \" + l);\n    yield \" */\";\n  }\n  yield `export interface ${docType.name} {`;\n  yield* indent(\n    writeField({\n      name: \"docType\",\n      type: `\"${docType.originalDocType}\"`,\n      docContents: `Document type: \"${docType.originalDocType}\".`,\n    }),\n  );\n\n  yield* indent(\n    writeField({\n      name: \"fields\",\n      type: docType.name + \"Fields\",\n      docContents: \"Document fields.\",\n    }),\n  );\n\n  yield* indent(\n    flatMap(\n      [\n        {\n          name: \"boundingRegions\",\n          docContents: \"Bounding regions covering the document.\",\n          type: \"fr.BoundingRegion[]\",\n          optional: true,\n        },\n        {\n          name: \"spans\",\n          docContents:\n            \"Locations of the document's elements in the `content` text (reading-order-concatenated content).\",\n          type: \"fr.DocumentSpan[]\",\n        },\n        {\n          name: \"confidence\",\n          docContents: \"The service's confidence that it has correctly extracted the document.\",\n          type: \"number\",\n        },\n      ],\n      writeField,\n    ),\n  );\n\n  yield \"}\";\n}\n\n/**\n * Write a field and its comment to an iterable of strings.\n */\nfunction* writeField(field: Field): Iterable<string> {\n  yield \"/**\";\n  yield* field.docContents.split(/\\r?\\n/).map((line) => ` * ${line}`);\n  yield \" */\";\n\n  // If the field name has an illegal character, we need to quote it.\n  const needsQuotes = !/^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(field.name);\n  const printedFieldName = needsQuotes ? `\"${field.name}\"` : field.name;\n\n  yield `${printedFieldName}${field.optional ? \"?\" : \"\"}: ${field.type};`;\n}\n\n/**\n * Recursively write the fields interfaces for a given document type.\n */\nfunction* writeFieldsInterfaces(docType: DocType): Iterable<string> {\n  const name = docType.name + \"Fields\";\n\n  yield* writeInterfaceDeclaration(name, docType.description, docType.fieldSchema);\n\n  // Recursively visit all child interfaces and write them.\n  yield* (function* collectNestedInterfaces(\n    fields: Record<string, DocumentFieldSchema>,\n    namingContext: string,\n  ): Iterable<string> {\n    for (const [fieldName, schema] of Object.entries(fields)) {\n      if (schema.type === \"array\" && schema.items?.type === \"object\") {\n        // Generate element interface and recur if the nested type is an object\n\n        const nextNamingContext = namingContext + fieldName + \"Element\";\n\n        yield \"\";\n        yield \"\";\n        yield* writeInterfaceDeclaration(\n          nextNamingContext,\n          schema.description,\n          schema.items?.properties ?? {},\n        );\n\n        yield* collectNestedInterfaces(schema.items?.properties ?? {}, nextNamingContext);\n      } else if (schema.type === \"object\") {\n        // Generate named interface and recur\n\n        yield \"\";\n        yield \"\";\n        yield* writeInterfaceDeclaration(\n          namingContext + fieldName,\n          schema.description,\n          schema.properties ?? {},\n        );\n\n        yield* collectNestedInterfaces(schema.properties ?? {}, namingContext + fieldName);\n      }\n    }\n  })(docType.fieldSchema, docType.name);\n\n  /**\n   * Write a simple interface declaration.\n   *\n   * @param interfaceName - the symbolic name of the interface\n   * @param description - the interface's documentation string.\n   * @param fields - the fields of the interface (a map of names to schemas)\n   */\n  function* writeInterfaceDeclaration(\n    interfaceName: string,\n    description: string | undefined,\n    fields: Record<string, DocumentFieldSchema>,\n  ): Generator<string, void, any> {\n    yield \"/**\";\n    yield ` * Describes the fields of \\`${interfaceName}\\`.`;\n    if (description) {\n      yield \" * \";\n      yield* description.split(/\\r?\\n/).map((l) => \" * \" + l);\n    }\n    yield \" */\";\n    const prefix = `export interface ${interfaceName} {`;\n    const suffix = \"}\";\n\n    const fieldEntries = Object.entries(fields);\n\n    if (fieldEntries.length === 0) {\n      yield prefix + suffix;\n    } else {\n      yield prefix;\n      yield* indent(\n        flatMap(\n          fieldEntries.map(([fieldName, schema]) => ({\n            // Uncapitalize the field name and remove all whitespace\n            name: uncapitalize(fieldName).replace(/\\s/g, \"\"),\n            type: writeType(schema, fieldName, docType.slug),\n            docContents: schema.description ?? `\\`${docType.name}\\` \"${fieldName}\" field`,\n            optional: true as const,\n          })),\n          writeField,\n        ),\n      );\n      yield suffix;\n    }\n  }\n}\n\n/**\n * Generate a type name for a field schema.\n *\n * @param schema - the schema of the type\n * @param name - the name to append to the field type, if necessary (only applies to objects and arrays)\n * @param slug - the current taxonomic naming context of the field name (used to name object types)\n * @returns a string representing the type name for the field\n */\nfunction writeType(schema: DocumentFieldSchema, name: string, slug: string[]): string {\n  const kind = schema.type as DocumentField[\"kind\"];\n\n  if (kind === \"array\") {\n    return `fr.DocumentArrayField<${writeType(schema.items!, \"Element\", [...slug, name])}>`;\n  } else if (kind === \"object\") {\n    const propertiesName = slug.map(capitalize).join(\"\") + name;\n    return `fr.DocumentObjectField<${propertiesName}>`;\n  } else {\n    return {\n      integer: \"fr.DocumentIntegerField\",\n      string: \"fr.DocumentStringField\",\n      countryRegion: \"fr.DocumentCountryRegionField\",\n      currency: \"fr.DocumentCurrencyField\",\n      time: \"fr.DocumentTimeField\",\n      date: \"fr.DocumentDateField\",\n      number: \"fr.DocumentNumberField\",\n      boolean: \"fr.DocumentBooleanField\",\n      phoneNumber: \"fr.DocumentPhoneNumberField\",\n      selectionMark: \"fr.DocumentSelectionMarkField\",\n      signature: \"fr.DocumentSignatureField\",\n      address: \"fr.DocumentAddressField\",\n    }[kind];\n  }\n}\n\n/**\n * Generate an AnalyzeResult-level interface.\n *\n * @param name - the name of the interface.\n * @param documentInterfaceName - the name of the interface's document type.\n * @param features - the features supported by the model\n */\nfunction* writeResultInterface(\n  name: string,\n  documentInterfaceName: string,\n  features: string[],\n): Iterable<string> {\n  const hasDocuments = features.some((f) => f === \"_documents\");\n\n  yield `export interface ${name} extends fr.AnalyzeResultCommon {`;\n  yield* indent(\n    flatMap(\n      features.filter((f) => f !== \"_documents\"),\n      (f) => writeField(defaultResultFields[f]),\n    ),\n  );\n  if (hasDocuments) {\n    yield* indent(\n      writeField({\n        name: \"documents\",\n        type: documentInterfaceName + \"[]\",\n        docContents: \"Extracted documents.\",\n      }),\n    );\n  }\n  yield \"}\";\n}\n\n/**\n * A helper function to indent an iterable.\n */\nfunction* indent(contents: Iterable<string>, level: number = 2): Iterable<string> {\n  const indentationString = \" \".repeat(level);\n\n  for (const line of contents) {\n    yield indentationString + line;\n  }\n}\n\n/**\n * A `flatMap` helper that works with generic iterables, not only arrays. If the result of `f` is iterable, its elements\n * will be produced instead of itself.\n *\n * @param it - the iterable to map over\n * @param f - the function to apply to each item in `it`\n */\nfunction* flatMap<T1, T2>(it: Iterable<T1>, f: (v: T1) => T2 | Iterable<T2>): Iterable<T2> {\n  for (const value of it) {\n    const result = f(value);\n    if (typeof result === \"object\" && result !== null && Symbol.iterator in result) {\n      yield* result as Iterable<T2>;\n    } else {\n      yield result as T2;\n    }\n  }\n}\n\n/**\n * Helper interface for representing a DocType during generation, allowing for renaming and contextual, taxonomic naming.\n */\ninterface DocType extends DocumentTypeDetails {\n  originalDocType: string;\n  name: string;\n  slug: string[];\n}\n"]}