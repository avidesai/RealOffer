"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentAnalysisClient = void 0;
const core_tracing_1 = require("@azure/core-tracing");
const constants_js_1 = require("./constants.js");
const parameters_js_1 = require("./generated/models/parameters.js");
const analysis_js_1 = require("./lro/analysis.js");
const poller_js_1 = require("./lro/util/poller.js");
const util_js_1 = require("./util.js");
/**
 * A client for interacting with the Form Recognizer service's analysis features.
 *
 * ### Examples:
 *
 * The Form Recognizer service and clients support two means of authentication:
 *
 * #### Azure Active Directory
 *
 * ```ts snippet:ReadmeSampleCreateClient_TokenCredential
 * import { DefaultAzureCredential } from "@azure/identity";
 * import { DocumentAnalysisClient } from "@azure/ai-form-recognizer";
 *
 * const credential = new DefaultAzureCredential();
 * const client = new DocumentAnalysisClient(
 *   "https://<resource name>.cognitiveservices.azure.com",
 *   credential,
 * );
 * ```
 *
 * #### API Key (Subscription Key)
 *
 * ```ts snippet:ReadmeSampleCreateClient_KeyCredential
 * import { AzureKeyCredential, DocumentAnalysisClient } from "@azure/ai-form-recognizer";
 *
 * const credential = new AzureKeyCredential("<API key>");
 * const client = new DocumentAnalysisClient(
 *   "https://<resource name>.cognitiveservices.azure.com",
 *   credential,
 * );
 * ```
 */
class DocumentAnalysisClient {
    constructor(endpoint, credential, options = {}) {
        this._restClient = (0, util_js_1.makeServiceClient)(endpoint, credential, options);
        this._tracing = (0, core_tracing_1.createTracingClient)({
            packageName: "@azure/ai-form-recognizer",
            packageVersion: constants_js_1.SDK_VERSION,
            namespace: "Microsoft.CognitiveServices",
        });
    }
    async beginAnalyzeDocument(model, document, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return this._tracing.withSpan("DocumentAnalysisClient.beginAnalyzeDocument", options, 
        // In the first version of the SDK, the document input was treated as a URL if it was a string, and we preserve
        // this behavior to avoid introducing a breaking change.
        this.analyze.bind(this, model, typeof document === "string" ? source("url", document) : source("body", document)));
    }
    async beginAnalyzeDocumentFromUrl(model, documentUrl, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return this._tracing.withSpan("DocumentAnalysisClient.beginAnalyzeDocumentFromUrl", options, this.analyze.bind(this, model, source("url", documentUrl)));
    }
    /**
     * A helper method for running analysis polymorphically.
     *
     * @param model - the model ID or DocumentModel to use for analysis
     * @param input - the string URL or request body to use
     * @param options - analysis options
     * @returns - an analysis poller
     */
    analyze(model, input, options) {
        const { modelId: initialModelId, apiVersion: requestApiVersion, transformResult, } = typeof model === "string"
            ? { modelId: model, apiVersion: undefined, transformResult: (v) => v }
            : model;
        if (requestApiVersion && requestApiVersion !== constants_js_1.FORM_RECOGNIZER_API_VERSION) {
            throw new Error([
                `API Version mismatch: the provided model wants version: ${requestApiVersion},`,
                `but the client is using ${constants_js_1.FORM_RECOGNIZER_API_VERSION}.`,
                "The API version of the model must match the client's API version.",
            ].join(" "));
        }
        return this.createUnifiedPoller((abortSignal) => {
            const [contentType, analyzeRequest] = toAnalyzeRequest(input);
            if (contentType === "application/json") {
                return this._restClient.documentModels.analyzeDocument(initialModelId, contentType, Object.assign(Object.assign({}, options), { abortSignal,
                    analyzeRequest }));
            }
            else {
                return this._restClient.documentModels.analyzeDocument(initialModelId, contentType, Object.assign(Object.assign({}, options), { abortSignal,
                    analyzeRequest }));
            }
        }, {
            initialModelId,
            options,
            transformResult: (result) => transformResult((0, analysis_js_1.toAnalyzeResultFromGenerated)(result)),
        });
    }
    /**
     * Classify a document using a custom classifier given by its ID.
     *
     * This method produces a long-running operation (poller) that will eventually produce an `AnalyzeResult`. This is the
     * same type as `beginAnalyzeDocument` and `beginAnalyzeDocumentFromUrl`, but the result will only contain a small
     * subset of its fields. Only the `documents` field and `pages` field will be populated, and only minimal page
     * information will be returned. The `documents` field will contain information about all the identified documents and
     * the `docType` that they were classified as.
     *
     * ### Example
     *
     * This method supports streamable request bodies ({@link FormRecognizerRequestBody}) such as Node.JS `ReadableStream`
     * objects, browser `Blob`s, and `ArrayBuffer`s. The contents of the body will be uploaded to the service for analysis.
     *
     * ```ts snippet:ReadmeSampleClassifyDocument_File
     * import { DefaultAzureCredential } from "@azure/identity";
     * import { DocumentAnalysisClient } from "@azure/ai-form-recognizer";
     * import { createReadStream } from "node:fs";
     *
     * const credential = new DefaultAzureCredential();
     * const client = new DocumentAnalysisClient(
     *   "https://<resource name>.cognitiveservices.azure.com",
     *   credential,
     * );
     *
     * const path = "<path to a document>";
     * const readStream = createReadStream(path);
     *
     * const poller = await client.beginClassifyDocument("<classifier id>", readStream);
     *
     * const result = await poller.pollUntilDone();
     *
     * if (result?.documents?.length === 0) {
     *   throw new Error("Failed to extract any documents.");
     * }
     *
     * for (const document of result.documents) {
     *   console.log(
     *     `Extracted a document with type '${document.docType}' on page ${document.boundingRegions?.[0].pageNumber} (confidence: ${document.confidence})`,
     *   );
     * }
     * ```
     *
     * @param classifierId - the ID of the custom classifier to use for analysis
     * @param document - the document to classify
     * @param options - options for the classification operation
     * @returns a long-running operation (poller) that will eventually produce an `AnalyzeResult`
     */
    async beginClassifyDocument(classifierId, document, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return this._tracing.withSpan("DocumentAnalysisClient.beginClassifyDocument", options, this.classify.bind(this, classifierId, source("body", document)));
    }
    /**
     * Classify a document from a URL using a custom classifier given by its ID.
     *
     * This method produces a long-running operation (poller) that will eventually produce an `AnalyzeResult`. This is the
     * same type as `beginAnalyzeDocument` and `beginAnalyzeDocumentFromUrl`, but the result will only contain a small
     * subset of its fields. Only the `documents` field and `pages` field will be populated, and only minimal page
     * information will be returned. The `documents` field will contain information about all the identified documents and
     * the `docType` that they were classified as.
     *
     * ### Example
     *
     * This method supports extracting data from a file at a given URL. The Form Recognizer service will attempt to
     * download a file using the submitted URL, so the URL must be accessible from the public internet. For example, a SAS
     * token can be used to grant read access to a blob in Azure Storage, and the service will use the SAS-encoded URL to
     * request the file.
     *
     * ```ts snippet:ReadmeSampleClassifyDocument
     * import { DefaultAzureCredential } from "@azure/identity";
     * import { DocumentAnalysisClient } from "@azure/ai-form-recognizer";
     *
     * const credential = new DefaultAzureCredential();
     * const client = new DocumentAnalysisClient(
     *   "https://<resource name>.cognitiveservices.azure.com",
     *   credential,
     * );
     *
     * const documentUrl =
     *   "https://raw.githubusercontent.com/Azure/azure-sdk-for-js/main/sdk/formrecognizer/ai-form-recognizer/assets/invoice/Invoice_1.pdf";
     *
     * const poller = await client.beginClassifyDocumentFromUrl("<classifier id>", documentUrl);
     *
     * const result = await poller.pollUntilDone();
     *
     * if (result?.documents?.length === 0) {
     *   throw new Error("Failed to extract any documents.");
     * }
     *
     * for (const document of result.documents) {
     *   console.log(
     *     `Extracted a document with type '${document.docType}' on page ${document.boundingRegions?.[0].pageNumber} (confidence: ${document.confidence})`,
     *   );
     * }
     * ```
     * @param classifierId - the ID of the custom classifier to use for analysis
     * @param documentUrl - the URL of the document to classify
     * @param options -
     * @returns
     */
    async beginClassifyDocumentFromUrl(classifierId, documentUrl, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return this._tracing.withSpan("DocumentAnalysisClient.beginClassifyDocumentFromUrl", options, this.classify.bind(this, classifierId, source("url", documentUrl)));
    }
    /**
     * A helper method for running classification polymorphically.
     * @param classifierId - the ID of the classifier to use
     * @param input - the string URL or request body to use
     * @param options - analysis options
     * @returns an analysis poller
     */
    classify(classifierId, input, options) {
        return this.createUnifiedPoller(async (abortSignal) => {
            const [contentType, classifyRequest] = toAnalyzeRequest(input);
            if (contentType === "application/json") {
                return this._restClient.documentClassifiers.classifyDocument(classifierId, contentType, Object.assign(Object.assign({}, options), { abortSignal,
                    classifyRequest }));
            }
            else {
                return this._restClient.documentClassifiers.classifyDocument(classifierId, contentType, Object.assign(Object.assign({}, options), { abortSignal,
                    classifyRequest }));
            }
        }, {
            initialModelId: classifierId,
            options,
            transformResult: analysis_js_1.toAnalyzeResultFromGenerated,
        });
    }
    /**
     * Create an LRO poller that handles analysis operations.
     *
     * This is the meat of all analysis polling operations.
     *
     * @param startOperation - function that starts the operation and returns the operation location
     * @param definition - operation definition (initial model ID, operation transforms, request options)
     * @returns - an analysis poller that produces the given return types according to the operation spec
     */
    async createUnifiedPoller(startOperation, definition) {
        const { resumeFrom } = definition.options;
        // TODO: what should we do if resumeFrom.modelId is different from initialModelId?
        // And what do we do with the redundant input??
        const getAnalyzeResult = (ctx, operationLocation) => this._tracing.withSpan("DocumentAnalysisClient.createAnalysisPoller-getAnalyzeResult", definition.options, (finalOptions) => this._restClient.sendOperationRequest({
            options: Object.assign(Object.assign({ onResponse: async (rawResponse, ...args) => {
                    var _a;
                    // Capture the `Retry-After` header if it was sent.
                    const retryAfterHeader = rawResponse.headers.get("retry-after");
                    // Convert the header value to milliseconds. If the header is not a valid number, then it is an HTTP
                    // date.
                    if (retryAfterHeader) {
                        const retryAfterMs = Number(retryAfterHeader) * 1000;
                        if (!Number.isNaN(retryAfterMs)) {
                            ctx.updateDelay(retryAfterMs);
                        }
                        else {
                            ctx.updateDelay(Date.parse(retryAfterHeader) - Date.now());
                        }
                    }
                    else {
                        ctx.updateDelay(undefined);
                    }
                    // Forward the `onResponse` callback if it was provided.
                    return (_a = finalOptions.onResponse) === null || _a === void 0 ? void 0 : _a.call(finalOptions, rawResponse, ...args);
                } }, finalOptions), { 
                // We need to pass the abort signal from the context rather than from the options, since the user could
                // poll the LRO with a different AbortSignal than it was instantiated with.
                abortSignal: ctx.abortSignal }),
        }, {
            path: operationLocation,
            httpMethod: "GET",
            responses: {
                200: {
                    bodyMapper: util_js_1.Mappers.AnalyzeResultOperation,
                },
                default: {
                    bodyMapper: util_js_1.Mappers.ErrorResponse,
                },
            },
            // URL is fully-formed, so we don't need any query parameters
            headerParameters: [parameters_js_1.accept1],
            serializer: util_js_1.SERIALIZER,
        }));
        const toInit = 
        // If the user gave us a stored token, we'll poll it again
        resumeFrom !== undefined
            ? async (ctx) => this._tracing.withSpan("DocumentAnalysisClient.createAnalysisPoller-resume", definition.options, async () => {
                const { clientVersion, operationLocation, modelId } = JSON.parse(resumeFrom);
                if (!clientVersion || clientVersion !== constants_js_1.SDK_VERSION) {
                    throw new Error([
                        "Cannot restore poller from a serialized state from a different version of the client",
                        `library (restoreFrom: '${clientVersion}', current: '${constants_js_1.SDK_VERSION}').`,
                    ].join(" "));
                }
                const result = await getAnalyzeResult(ctx, operationLocation);
                return (0, analysis_js_1.toDocumentAnalysisPollOperationState)(definition, modelId, operationLocation, result);
            })
            : // Otherwise, we'll start a new operation from the initialModelId
                async (ctx) => this._tracing.withSpan("DocumentAnalysisClient.createAnalysisPoller-start", definition.options, async () => {
                    const { operationLocation } = await startOperation(ctx.abortSignal);
                    if (operationLocation === undefined) {
                        throw new Error("Unable to start analysis operation: no Operation-Location received.");
                    }
                    const result = await getAnalyzeResult(ctx, operationLocation);
                    return (0, analysis_js_1.toDocumentAnalysisPollOperationState)(definition, definition.initialModelId, operationLocation, result);
                });
        const poller = await (0, poller_js_1.lro)({
            init: toInit,
            poll: async (ctx, { operationLocation, modelId }) => this._tracing.withSpan("DocumentAnalysisClient.createAnalysisPoller-poll", {}, async () => {
                const result = await getAnalyzeResult(ctx, operationLocation);
                return (0, analysis_js_1.toDocumentAnalysisPollOperationState)(definition, modelId, operationLocation, result);
            }),
            serialize: ({ operationLocation, modelId }) => JSON.stringify({ clientVersion: constants_js_1.SDK_VERSION, id: modelId, operationLocation }),
        }, definition.options.updateIntervalInMs, definition.options.abortSignal);
        if (definition.options.onProgress !== undefined) {
            poller.onProgress(definition.options.onProgress);
            definition.options.onProgress(poller.getOperationState());
        }
        return poller;
    }
}
exports.DocumentAnalysisClient = DocumentAnalysisClient;
/**
 * Produce an appropriate pair of content-type and analyzeRequest value for the analysis request.
 * @internal
 */
function toAnalyzeRequest(input) {
    switch (input.kind) {
        case "body":
            return ["application/octet-stream", input.body];
        case "url":
            return ["application/json", { urlSource: input.url }];
        case "base64":
            return ["application/json", { base64Source: input.base64 }];
        default: {
            const __exhaust = input;
            throw new Error(`Unreachable 'toAnalyzeRequest' case: ${__exhaust}`);
        }
    }
}
/**
 * The input to a document analysis operation.
 */
// type DocumentSource = DocumentBodySource | DocumentUrlSource | DocumentBase64Source;
function source(kind, value) {
    return {
        kind,
        [kind]: value,
    };
}
//# sourceMappingURL=documentAnalysisClient.js.map