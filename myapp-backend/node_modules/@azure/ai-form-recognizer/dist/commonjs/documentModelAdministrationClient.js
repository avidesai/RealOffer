"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentModelAdministrationClient = void 0;
const core_tracing_1 = require("@azure/core-tracing");
const constants_js_1 = require("./constants.js");
const parameters_js_1 = require("./generated/models/parameters.js");
const administration_js_1 = require("./lro/administration.js");
const poller_js_1 = require("./lro/util/poller.js");
const util_js_1 = require("./util.js");
/**
 * A client for interacting with the Form Recognizer service's model management features, such as creating, reading,
 * listing, deleting, and copying models.
 *
 * ### Examples:
 *
 * #### Azure Active Directory
 *
 * ```ts snippet:ReadmeSampleAdministrationClient_TokenCredential
 * import { DefaultAzureCredential } from "@azure/identity";
 * import { DocumentModelAdministrationClient } from "@azure/ai-form-recognizer";
 *
 * const credential = new DefaultAzureCredential();
 * const client = new DocumentModelAdministrationClient(
 *   "https://<resource name>.cognitiveservices.azure.com",
 *   credential,
 * );
 * ```
 *
 * #### API Key (Subscription Key)
 *
 * ```ts snippet:ReadmeSampleAdministrationClient_KeyCredential
 * import { AzureKeyCredential, DocumentModelAdministrationClient } from "@azure/ai-form-recognizer";
 *
 * const credential = new AzureKeyCredential("<API key>");
 * const client = new DocumentModelAdministrationClient(
 *   "https://<resource name>.cognitiveservices.azure.com",
 *   credential,
 * );
 * ```
 */
class DocumentModelAdministrationClient {
    constructor(endpoint, credential, options = {}) {
        this._restClient = (0, util_js_1.makeServiceClient)(endpoint, credential, options);
        this._tracing = (0, core_tracing_1.createTracingClient)({
            packageName: "@azure/ai-form-recognizer",
            packageVersion: constants_js_1.SDK_VERSION,
            namespace: "Microsoft.CognitiveServices",
        });
    }
    async beginBuildDocumentModel(modelId, urlOrSource, buildMode, options = {}) {
        const sourceInfo = typeof urlOrSource === "string"
            ? {
                azureBlobSource: {
                    containerUrl: urlOrSource,
                },
            }
            : urlOrSource;
        return this._tracing.withSpan("DocumentModelAdministrationClient.beginBuildDocumentModel", options, (finalOptions) => this.createAdministrationPoller({
            options: finalOptions,
            start: (ctx) => this._restClient.documentModels.buildModel(Object.assign(Object.assign({ modelId, description: finalOptions.description }, sourceInfo), { buildMode }), Object.assign(Object.assign({}, finalOptions), { abortSignal: ctx.abortSignal })),
        }));
    }
    /**
     * Creates a single composed model from several pre-existing submodels.
     *
     * The resulting composed model combines the document types of its component models, and inserts a classification step
     * into the extraction pipeline to determine which of its component submodels is most appropriate for the given input.
     *
     * ### Example
     *
     * ```ts snippet:ReadmeSampleComposeModel
     * import { DefaultAzureCredential } from "@azure/identity";
     * import { DocumentModelAdministrationClient } from "@azure/ai-form-recognizer";
     *
     * const credential = new DefaultAzureCredential();
     * const client = new DocumentModelAdministrationClient(
     *   "https://<resource name>.cognitiveservices.azure.com",
     *   credential,
     * );
     *
     * const composeModelId = "aNewComposedModel";
     * const subModelIds = ["documentType1Model", "documentType2Model", "documentType3Model"];
     *
     * // The resulting composed model can classify and extract data from documents
     * // conforming to any of the above document types
     * const poller = await client.beginComposeDocumentModel(composeModelId, subModelIds, {
     *   description: "This is a composed model that can handle several document types.",
     * });
     * // Model composition, like all other model creation operations, returns a poller that eventually produces a
     * // ModelDetails object
     * const modelDetails = await poller.pollUntilDone();
     *
     * const {
     *   modelId, // identical to the modelId given when creating the model
     *   description, // identical to the description given when creating the model
     *   createdOn, // the Date (timestamp) that the model was created
     *   docTypes, // information about the document types of the composed submodels
     * } = modelDetails;
     * ```
     *
     * @param modelId - the unique ID of the model to create
     * @param componentModelIds - an Iterable of strings representing the unique model IDs of the models to compose
     * @param options - optional settings for model creation
     * @returns a long-running operation (poller) that will eventually produce the created model information or an error
     */
    async beginComposeDocumentModel(modelId, componentModelIds, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.beginComposeDocumentModel", options, (finalOptions) => this.createAdministrationPoller({
            options: finalOptions,
            start: (ctx) => this._restClient.documentModels.composeModel({
                modelId,
                componentModels: [...componentModelIds].map((submodelId) => ({
                    modelId: submodelId,
                })),
                description: finalOptions.description,
                tags: finalOptions.tags,
            }, Object.assign(Object.assign({}, finalOptions), { abortSignal: ctx.abortSignal })),
        }));
    }
    /**
     * Creates an authorization to copy a model into the resource, used with the `beginCopyModelTo` method.
     *
     * The `CopyAuthorization` grants another cognitive service resource the right to create a model in this client's
     * resource with the model ID and optional description that are encoded into the authorization.
     *
     * ### Example
     *
     * ```ts snippet:ReadmeSampleGetCopyAuthorization
     * import { DefaultAzureCredential } from "@azure/identity";
     * import { DocumentModelAdministrationClient } from "@azure/ai-form-recognizer";
     *
     * const credential = new DefaultAzureCredential();
     * const client = new DocumentModelAdministrationClient(
     *   "https://<resource name>.cognitiveservices.azure.com",
     *   credential,
     * );
     *
     * // The copyAuthorization data structure stored below grants any cognitive services resource the right to copy a
     * // model into the client's resource with the given destination model ID.
     * const copyAuthorization = await client.getCopyAuthorization("<destination model ID>");
     * ```
     *
     * @param destinationModelId - the unique ID of the destination model (the ID to copy the model into)
     * @param options - optional settings for creating the copy authorization
     * @returns a copy authorization that encodes the given modelId and optional description
     */
    async getCopyAuthorization(destinationModelId, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.getCopyAuthorization", options, (finalOptions) => this._restClient.documentModels.authorizeModelCopy({
            modelId: destinationModelId,
            description: finalOptions.description,
            tags: finalOptions.tags,
        }, finalOptions));
    }
    /**
     * Copies a model with the given ID into the resource and model ID encoded by a given copy authorization.
     *
     * See {@link CopyAuthorization} and {@link getCopyAuthorization}.
     *
     * ### Example
     *
     * ```ts snippet:ReadmeSampleCopyModel
     * import { DefaultAzureCredential } from "@azure/identity";
     * import { DocumentModelAdministrationClient, AzureKeyCredential } from "@azure/ai-form-recognizer";
     *
     * const credential = new DefaultAzureCredential();
     * const client = new DocumentModelAdministrationClient(
     *   "https://<resource name>.cognitiveservices.azure.com",
     *   credential,
     * );
     *
     * // We create the copy authorization using a client authenticated with the destination resource. Note that these two
     * // resources can be the same (you can copy a model to a new ID in the same resource).
     * const copyAuthorization = await client.getCopyAuthorization("<destination model ID>");
     *
     * // Finally, use the _source_ client to copy the model and await the copy operation
     * // We need a client for the source model's resource
     * const sourceEndpoint = "https://<source resource name>.cognitiveservices.azure.com";
     * const sourceCredential = new AzureKeyCredential("<source api key>");
     * const sourceClient = new DocumentModelAdministrationClient(sourceEndpoint, sourceCredential);
     * const poller = await sourceClient.beginCopyModelTo("<source model ID>", copyAuthorization);
     *
     * // Model copying, like all other model creation operations, returns a poller that eventually produces a ModelDetails
     * // object
     * const modelDetails = await poller.pollUntilDone();
     *
     * const {
     *   modelId, // identical to the modelId given when creating the copy authorization
     *   description, // identical to the description given when creating the copy authorization
     *   createdOn, // the Date (timestamp) that the model was created
     *   docTypes, // information about the document types of the model (identical to the original, source model)
     * } = modelDetails;
     * ```
     *
     * @param sourceModelId - the unique ID of the source model that will be copied
     * @param authorization - an authorization to copy the model, created using the {@link getCopyAuthorization}
     * @param options - optional settings for
     * @returns a long-running operation (poller) that will eventually produce the copied model information or an error
     */
    async beginCopyModelTo(sourceModelId, authorization, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.beginCopyModel", options, (finalOptions) => this.createAdministrationPoller({
            options: finalOptions,
            start: () => this._restClient.documentModels.copyModelTo(sourceModelId, authorization, finalOptions),
        }));
    }
    // #endregion
    // #region Document Classifiers
    /**
     * Build a new document classifier with the given classifier ID and document types.
     *
     * The classifier ID must be unique among classifiers within the resource.
     *
     * The document types are given as an object that maps the name of the document type to the training data set for that
     * document type. Two training data input methods are supported:
     *
     * - `azureBlobSource`, which trains a classifier using the data in the given Azure Blob Storage container.
     * - `azureBlobFileListSource`, which is similar to `azureBlobSource` but allows for more fine-grained control over
     *   the files that are included in the training data set by using a JSONL-formatted file list.
     *
     * The Form Recognizer service reads the training data set from an Azure Storage container, given as a URL to the
     * container with a SAS token that allows the service backend to communicate with the container. At a minimum, the
     * "read" and "list" permissions are required. In addition, the data in the given container must be organized
     * according to a particular convention, which is documented in [the service's documentation for building custom
     * document classifiers](https://aka.ms/azsdk/formrecognizer/buildclassifiermodel).
     *
     * ### Example
     *
     * ```ts snippet:ReadmeSampleBuildClassifier
     * import { DefaultAzureCredential } from "@azure/identity";
     * import { DocumentModelAdministrationClient } from "@azure/ai-form-recognizer";
     *
     * const credential = new DefaultAzureCredential();
     * const client = new DocumentModelAdministrationClient(
     *   "https://<resource name>.cognitiveservices.azure.com",
     *   credential,
     * );
     *
     * const newClassifiedId = "aNewClassifier";
     * const containerUrl1 = "<training data container SAS URL 1>";
     * const containerUrl2 = "<training data container SAS URL 2>";
     *
     * const poller = await client.beginBuildDocumentClassifier(
     *   newClassifiedId,
     *   {
     *     // The document types. Each entry in this object should map a document type name to a
     *     // `ClassifierDocumentTypeDetails` object
     *     formX: {
     *       azureBlobSource: {
     *         containerUrl: containerUrl1,
     *       },
     *     },
     *     formY: {
     *       azureBlobFileListSource: {
     *         containerUrl: containerUrl2,
     *         fileList: "path/to/fileList.jsonl",
     *       },
     *     },
     *   },
     *   {
     *     // Optionally, a text description may be attached to the classifier
     *     description: "This is an example classifier!",
     *   },
     * );
     *
     * // Classifier building, like model creation operations, returns a poller that eventually produces a
     * // DocumentClassifierDetails object
     * const classifierDetails = await poller.pollUntilDone();
     *
     * const {
     *   classifierId, // identical to the classifierId given when creating the classifier
     *   description, // identical to the description given when creating the classifier (if any)
     *   createdOn, // the Date (timestamp) that the classifier was created
     *   docTypes, // information about the document types in the classifier and their details
     * } = classifierDetails;
     * ```
     *
     * @param classifierId - the unique ID of the classifier to create
     * @param docTypeSources - the document types to include in the classifier and their sources (a map of document type
     *                         names to `ClassifierDocumentTypeDetails`)
     * @param options - optional settings for the classifier build operation
     * @returns a long-running operation (poller) that will eventually produce the created classifier details or an error
     */
    async beginBuildDocumentClassifier(classifierId, docTypeSources, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.beginBuildDocumentClassifier", options, (finalOptions) => this.createAdministrationPoller({
            options: finalOptions,
            start: () => this._restClient.documentClassifiers.buildClassifier({
                classifierId,
                description: finalOptions.description,
                docTypes: docTypeSources,
            }, finalOptions),
        }));
    }
    // #endregion
    /**
     * Create an LRO poller that handles model creation operations.
     *
     * This is the meat of the above model creation operations.
     *
     * @param definition - operation definition (start operation method, request options)
     * @returns a model poller (produces a ModelDetails)
     */
    async createAdministrationPoller(definition) {
        const { resumeFrom } = definition.options;
        const toInit = resumeFrom === undefined
            ? (ctx) => this._tracing.withSpan("DocumentModelAdministrationClient.createDocumentModelPoller-start", definition.options, async (options) => {
                const { operationLocation } = await definition.start(ctx);
                if (operationLocation === undefined) {
                    throw new Error("Unable to start model creation operation: no Operation-Location received.");
                }
                return this._restClient.sendOperationRequest({
                    options: Object.assign(Object.assign({ onResponse: (rawResponse, ...args) => {
                            return captureRetryAfter(rawResponse, ctx, options, args);
                        } }, options), { abortSignal: ctx.abortSignal }),
                }, {
                    path: operationLocation,
                    httpMethod: "GET",
                    responses: {
                        200: {
                            bodyMapper: util_js_1.Mappers.OperationDetails,
                        },
                        default: {
                            bodyMapper: util_js_1.Mappers.ErrorResponse,
                        },
                    },
                    headerParameters: [parameters_js_1.accept1],
                    serializer: util_js_1.SERIALIZER,
                });
            })
            : (ctx) => this._tracing.withSpan("DocumentModelAdministrationClient.createDocumentModelPoller-resume", definition.options, (options) => {
                const { operationId } = JSON.parse(resumeFrom);
                return this._restClient.miscellaneous.getOperation(operationId, Object.assign({ onResponse: (rawResponse, ...args) => {
                        return captureRetryAfter(rawResponse, ctx, options, args);
                    } }, options));
            });
        const poller = await (0, poller_js_1.lro)({
            init: async (ctx) => (0, administration_js_1.toTrainingPollOperationState)(await toInit(ctx)),
            poll: async (ctx, { operationId }) => this._tracing.withSpan("DocumentModelAdminstrationClient.createDocumentModelPoller-poll", definition.options, async (options) => {
                const res = await this._restClient.miscellaneous.getOperation(operationId, Object.assign(Object.assign({ onResponse: (rawResponse, ...args) => {
                        // Capture the `Retry-After` header if it was sent.
                        return captureRetryAfter(rawResponse, ctx, options, args);
                    } }, options), { abortSignal: ctx.abortSignal }));
                return (0, administration_js_1.toTrainingPollOperationState)(res);
            }),
            serialize: ({ operationId }) => JSON.stringify({ operationId }),
        }, definition.options.updateIntervalInMs, definition.options.abortSignal);
        if (definition.options.onProgress !== undefined) {
            poller.onProgress(definition.options.onProgress);
            definition.options.onProgress(poller.getOperationState());
        }
        // Need this assertion. The poller above is dynamic, and we can't infer the conditional return type of this method.
        return poller;
        /**
         * An inline helper for capturing the value of the `Retry-After` header if it was sent.
         * @param rawResponse - the raw response from the service
         * @param ctx - the operation context
         * @param options - the operation options
         * @param args - the arguments passed to the response handler
         * @returns
         */
        function captureRetryAfter(rawResponse, ctx, options, args) {
            var _a;
            const retryAfterHeader = rawResponse.headers.get("retry-after");
            // Convert the header value to milliseconds. If the header is not a valid number, then it is an HTTP
            // date.
            if (retryAfterHeader) {
                const retryAfterMs = Number(retryAfterHeader) * 1000;
                if (!Number.isNaN(retryAfterMs)) {
                    ctx.updateDelay(retryAfterMs);
                }
                else {
                    ctx.updateDelay(Date.parse(retryAfterHeader) - Date.now());
                }
            }
            else {
                ctx.updateDelay(undefined);
            }
            // Forward the `onResponse` callback if it was provided.
            return (_a = options.onResponse) === null || _a === void 0 ? void 0 : _a.call(options, rawResponse, ...args);
        }
    }
    // #region Model Management
    /**
     * Retrieve basic information about this client's resource.
     *
     * ### Example
     *
     * ```ts snippet:ReadmeSampleGetResourceDetails
     * import { DefaultAzureCredential } from "@azure/identity";
     * import { DocumentModelAdministrationClient } from "@azure/ai-form-recognizer";
     *
     * const credential = new DefaultAzureCredential();
     * const client = new DocumentModelAdministrationClient(
     *   "https://<resource name>.cognitiveservices.azure.com",
     *   credential,
     * );
     *
     * const {
     *   // Information about the custom models in the current resource
     *   customDocumentModels: {
     *     // The number of custom models in the current resource
     *     count,
     *     // The maximum number of models that the current resource can support
     *     limit,
     *   },
     * } = await client.getResourceDetails();
     * ```
     *
     * @param options - optional settings for the request
     * @returns basic information about this client's resource
     */
    getResourceDetails(options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.getResourceDetails", options, (finalOptions) => this._restClient.miscellaneous.getResourceInfo(finalOptions));
    }
    /**
     * Retrieves information about a model ({@link DocumentModelDetails}) by ID.
     *
     * This method can retrieve information about custom as well as prebuilt models.
     *
     * ### **Breaking Change**
     *
     * In previous versions of the Form Recognizer REST API and SDK, the `getModel` method could return any model, even
     * one that failed to create due to errors. In the new service versions, `getDocumentModel` and `listDocumentModels`
     * _only produce successfully created models_ (i.e. models that are "ready" for use). Failed models are now retrieved
     * through the "operations" APIs, see {@link getOperation} and {@link listOperations}.
     *
     * ### Example
     *
     * ```ts snippet:ReadmeSampleGetModel
     * import { DefaultAzureCredential } from "@azure/identity";
     * import { DocumentModelAdministrationClient } from "@azure/ai-form-recognizer";
     *
     * const credential = new DefaultAzureCredential();
     * const client = new DocumentModelAdministrationClient(
     *   "https://<resource name>.cognitiveservices.azure.com",
     *   credential,
     * );
     *
     * // The ID of the prebuilt business card model
     * const prebuiltModelId = "prebuilt-businessCard";
     *
     * const {
     *   modelId, // identical to the modelId given when calling `getDocumentModel`
     *   description, // a textual description of the model, if provided during model creation
     *   createdOn, // the Date (timestamp) that the model was created
     *   // information about the document types in the model and their field schemas
     *   docTypes: {
     *     // the document type of the prebuilt business card model
     *     "prebuilt:businesscard": {
     *       // an optional, textual description of this document type
     *       description: businessCardDescription,
     *       // the schema of the fields in this document type, see the FieldSchema type
     *       fieldSchema,
     *       // the service's confidences in the fields (an object with field names as properties and numeric confidence
     *       // values)
     *       fieldConfidence,
     *     },
     *   },
     * } = await client.getDocumentModel(prebuiltModelId);
     * ```
     *
     * @param modelId - the unique ID of the model to query
     * @param options - optional settings for the request
     * @returns information about the model with the given ID
     */
    getDocumentModel(modelId, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.getDocumentModel", options, (finalOptions) => this._restClient.documentModels.getModel(modelId, finalOptions));
    }
    /**
     * List summaries of models in the resource. Custom as well as prebuilt models will be included. This operation
     * supports paging.
     *
     * The model summary ({@link DocumentModelSummary}) includes only the basic information about the model, and does not include
     * information about the document types in the model (such as the field schemas and confidence values).
     *
     * To access the full information about the model, use {@link getDocumentModel}.
     *
     * ### **Breaking Change**
     *
     * In previous versions of the Form Recognizer REST API and SDK, the `listModels` method would return all models, even
     * those that failed to create due to errors. In the new service versions, `listDocumentModels` and `getDocumentModel`
     * _only produce successfully created models_ (i.e. models that are "ready" for use). Failed models are now retrieved
     * through the "operations" APIs, see {@link getOperation} and {@link listOperations}.
     *
     * ### Examples
     *
     * #### Async Iteration
     *
     * ```ts snippet:ReadmeSampleListModels
     * import { DefaultAzureCredential } from "@azure/identity";
     * import { DocumentModelAdministrationClient } from "@azure/ai-form-recognizer";
     *
     * const credential = new DefaultAzureCredential();
     * const client = new DocumentModelAdministrationClient(
     *   "https://<resource name>.cognitiveservices.azure.com",
     *   credential,
     * );
     *
     * // Iterate over all models in the current resource
     * for await (const summary of client.listDocumentModels()) {
     *   const {
     *     modelId, // The model's unique ID
     *     description, // a textual description of the model, if provided during model creation
     *   } = summary;
     *
     *   // You can get the full model info using `getDocumentModel`
     *   const model = await client.getDocumentModel(modelId);
     * }
     *
     * // The listDocumentModels method is paged, and you can iterate by page using the `byPage` method.
     * const pages = client.listDocumentModels().byPage();
     *
     * for await (const page of pages) {
     *   // Each page is an array of models and can be iterated synchronously
     *   for (const summary of page) {
     *     const {
     *       modelId, // The model's unique ID
     *       description, // a textual description of the model, if provided during model creation
     *     } = summary;
     *
     *     // You can get the full model info using `getDocumentModel`
     *     const model = await client.getDocumentModel(modelId);
     *   }
     * }
     * ```
     *
     * @param options - optional settings for the model requests
     * @returns an async iterable of model summaries that supports paging
     */
    listDocumentModels(
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return this._restClient.documentModels.listModels(options);
    }
    /**
     * Deletes a model with the given ID from the client's resource, if it exists. This operation CANNOT be reverted.
     *
     * ### Example
     *
     * ```ts snippet:ReadmeSampleDeleteModel
     * import { DefaultAzureCredential } from "@azure/identity";
     * import { DocumentModelAdministrationClient } from "@azure/ai-form-recognizer";
     *
     * const credential = new DefaultAzureCredential();
     * const client = new DocumentModelAdministrationClient(
     *   "https://<resource name>.cognitiveservices.azure.com",
     *   credential,
     * );
     *
     * await client.deleteDocumentModel("<model ID to delete>");
     * ```
     *
     * @param modelId - the unique ID of the model to delete from the resource
     * @param options - optional settings for the request
     */
    deleteDocumentModel(modelId, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.deleteDocumentModel", options, (finalOptions) => this._restClient.documentModels.deleteModel(modelId, finalOptions));
    }
    // #endregion
    // #region Classifier Management
    /**
     * Retrieves information about a classifier ({@link DocumentClassifierDetails}) by ID.
     *
     * ### Example
     *
     * ```ts snippet:ReadmeSampleGetClassifier
     * import { DefaultAzureCredential } from "@azure/identity";
     * import { DocumentModelAdministrationClient } from "@azure/ai-form-recognizer";
     *
     * const credential = new DefaultAzureCredential();
     * const client = new DocumentModelAdministrationClient(
     *   "https://<resource name>.cognitiveservices.azure.com",
     *   credential,
     * );
     *
     * const foundClassifier = "<classifier ID>";
     *
     * const {
     *   classifierId, // identical to the ID given when calling `getDocumentClassifier`
     *   description, // a textual description of the classifier, if provided during classifier creation
     *   createdOn, // the Date (timestamp) that the classifier was created
     *   // information about the document types in the classifier and their corresponding traning data
     *   docTypes,
     * } = await client.getDocumentClassifier(foundClassifier);
     *
     * // The `docTypes` property is a map of document type names to information about the training data
     * // for that document type.
     * for (const [docTypeName, classifierDocTypeDetails] of Object.entries(docTypes)) {
     *   console.log(`- '${docTypeName}': `, classifierDocTypeDetails);
     * }
     * ```
     *
     * @param classifierId - the unique ID of the classifier to query
     * @param options - optional settings for the request
     * @returns information about the classifier with the given ID
     */
    getDocumentClassifier(classifierId, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.getDocumentClassifier", options, (finalOptions) => this._restClient.documentClassifiers.getClassifier(classifierId, finalOptions));
    }
    /**
     * List details about classifiers in the resource. This operation supports paging.
     *
     * ### Examples
     *
     * #### Async Iteration
     *
     * ```ts snippet:ReadmeSampleListClassifiers
     * import { DefaultAzureCredential } from "@azure/identity";
     * import { DocumentModelAdministrationClient } from "@azure/ai-form-recognizer";
     *
     * const credential = new DefaultAzureCredential();
     * const client = new DocumentModelAdministrationClient(
     *   "https://<resource name>.cognitiveservices.azure.com",
     *   credential,
     * );
     *
     * for await (const details of client.listDocumentClassifiers()) {
     *   const {
     *     classifierId, // The classifier's unique ID
     *     description, // a textual description of the classifier, if provided during creation
     *     docTypes, // information about the document types in the classifier and their corresponding traning data
     *   } = details;
     * }
     *
     * // The listDocumentClassifiers method is paged, and you can iterate by page using the `byPage` method.
     * const pages = client.listDocumentClassifiers().byPage();
     *
     * for await (const page of pages) {
     *   // Each page is an array of classifiers and can be iterated synchronously
     *   for (const details of page) {
     *     const {
     *       classifierId, // The classifier's unique ID
     *       description, // a textual description of the classifier, if provided during creation
     *       docTypes, // information about the document types in the classifier and their corresponding traning data
     *     } = details;
     *   }
     * }
     * ```
     *
     * @param options - optional settings for the classifier requests
     * @returns an async iterable of classifier details that supports paging
     */
    listDocumentClassifiers(
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return this._restClient.documentClassifiers.listClassifiers(options);
    }
    /**
     * Deletes a classifier with the given ID from the client's resource, if it exists. This operation CANNOT be reverted.
     *
     * ### Example
     *
     * ```ts snippet:ReadmeSampleDeleteClassifier
     * import { DefaultAzureCredential } from "@azure/identity";
     * import { DocumentModelAdministrationClient } from "@azure/ai-form-recognizer";
     *
     * const credential = new DefaultAzureCredential();
     * const client = new DocumentModelAdministrationClient(
     *   "https://<resource name>.cognitiveservices.azure.com",
     *   credential,
     * );
     *
     * await client.deleteDocumentClassifier("<classifier ID to delete>");
     * ```
     *
     * @param classifierId - the unique ID of the classifier to delete from the resource
     * @param options - optional settings for the request
     */
    deleteDocumentClassifier(classifierId, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.deleteDocumentClassifier", options, (finalOptions) => this._restClient.documentClassifiers.deleteClassifier(classifierId, finalOptions));
    }
    // #endregion
    // #region Operations
    /**
     * Retrieves information about an operation (`OperationDetails`) by its ID.
     *
     * Operations represent non-analysis tasks, such as building, composing, or copying a model.
     *
     * @param operationId - the ID of the operation to query
     * @param options - optional settings for the request
     * @returns information about the operation with the given ID
     *
     * ### Example
     *
     * ```ts snippet:ReadmeSampleGetOperation
     * import { DefaultAzureCredential } from "@azure/identity";
     * import { DocumentModelAdministrationClient } from "@azure/ai-form-recognizer";
     *
     * const credential = new DefaultAzureCredential();
     * const client = new DocumentModelAdministrationClient(
     *   "https://<resource name>.cognitiveservices.azure.com",
     *   credential,
     * );
     *
     * // The ID of the operation, which should be a GUID
     * const findOperationId = "<operation GUID>";
     *
     * const {
     *   operationId, // identical to the operationId given when calling `getOperation`
     *   kind, // the operation kind, one of "documentModelBuild", "documentModelCompose", or "documentModelCopyTo"
     *   status, // the status of the operation, one of "notStarted", "running", "failed", "succeeded", or "canceled"
     *   percentCompleted, // a number between 0 and 100 representing the progress of the operation
     *   createdOn, // a Date object that reflects the time when the operation was started
     *   lastUpdatedOn, // a Date object that reflects the time when the operation state was last modified
     * } = await client.getOperation(findOperationId);
     * ```
     */
    getOperation(operationId, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.getOperation", options, (finalOptions) => this._restClient.miscellaneous.getOperation(operationId, finalOptions));
    }
    /**
     * List model creation operations in the resource. This will produce all operations, including operations that failed
     * to create models successfully. This operation supports paging.
     *
     * ### Examples
     *
     * #### Async Iteration
     *
     * ```ts snippet:ReadmeSampleListOperations
     * import { DefaultAzureCredential } from "@azure/identity";
     * import { DocumentModelAdministrationClient } from "@azure/ai-form-recognizer";
     *
     * const credential = new DefaultAzureCredential();
     * const client = new DocumentModelAdministrationClient(
     *   "https://<resource name>.cognitiveservices.azure.com",
     *   credential,
     * );
     *
     * for await (const operation of client.listOperations()) {
     *   const {
     *     operationId, // the operation's GUID
     *     status, // the operation status, one of "notStarted", "running", "succeeded", "failed", or "canceled"
     *     percentCompleted, // the progress of the operation, from 0 to 100
     *   } = operation;
     * }
     *
     * // The listOperations method is paged, and you can iterate by page using the `byPage` method.
     * const pages = client.listOperations().byPage();
     *
     * for await (const page of pages) {
     *   // Each page is an array of operation info objects and can be iterated synchronously
     *   for (const operation of page) {
     *     const {
     *       operationId, // the operation's GUID
     *       status, // the operation status, one of "notStarted", "running", "succeeded", "failed", or "canceled"
     *       percentCompleted, // the progress of the operation, from 0 to 100
     *     } = operation;
     *   }
     * }
     * ```
     *
     * @param options - optional settings for the operation requests
     * @returns an async iterable of operation information objects that supports paging
     */
    listOperations(options = {}) {
        return this._restClient.miscellaneous.listOperations(options);
    }
}
exports.DocumentModelAdministrationClient = DocumentModelAdministrationClient;
//# sourceMappingURL=documentModelAdministrationClient.js.map