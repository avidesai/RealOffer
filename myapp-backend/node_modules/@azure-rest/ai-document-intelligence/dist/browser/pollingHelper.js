// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { createHttpPoller } from "@azure/core-lro";
export function getLongRunningPoller(client, initialResponse, options = {}) {
    const abortController = new AbortController();
    const poller = {
        sendInitialRequest: async () => {
            // In the case of Rest Clients we are building the LRO poller object from a response that's the reason
            // we are not triggering the initial request here, just extracting the information from the
            // response we were provided.
            return getLroResponse(initialResponse);
        },
        sendPollRequest: async (path, pollOptions) => {
            // This is the callback that is going to be called to poll the service
            // to get the latest status. We use the client provided and the polling path
            // which is an opaque URL provided by caller, the service sends this in one of the following headers: operation-location, azure-asyncoperation or location
            // depending on the lro pattern that the service implements. If non is provided we default to the initial path.
            function abortListener() {
                abortController.abort();
            }
            const inputAbortSignal = pollOptions === null || pollOptions === void 0 ? void 0 : pollOptions.abortSignal;
            const abortSignal = abortController.signal;
            if (inputAbortSignal === null || inputAbortSignal === void 0 ? void 0 : inputAbortSignal.aborted) {
                abortController.abort();
            }
            else if (!abortSignal.aborted) {
                inputAbortSignal === null || inputAbortSignal === void 0 ? void 0 : inputAbortSignal.addEventListener("abort", abortListener, {
                    once: true,
                });
            }
            let response;
            try {
                response = await client
                    .pathUnchecked(path !== null && path !== void 0 ? path : initialResponse.request.url)
                    .get({ abortSignal });
            }
            finally {
                inputAbortSignal === null || inputAbortSignal === void 0 ? void 0 : inputAbortSignal.removeEventListener("abort", abortListener);
            }
            const lroResponse = getLroResponse(response);
            lroResponse.rawResponse.headers["x-ms-original-url"] = initialResponse.request.url;
            return lroResponse;
        },
    };
    return createHttpPoller(poller, options);
}
/**
 * Returns the operation-id from the operation-location header
 */
function parseResultId(operationLocationHeader) {
    // regex to extract the operation id from the operation-location header with the regex "[^:]+://[^/]+/documentintelligence/.+/([^?/]+)"
    const regex = /[^:]+:\/\/[^/]+\/documentintelligence\/.+\/([^?/]+)/;
    const match = operationLocationHeader.match(regex);
    if (!match) {
        throw new Error(`Failed to parse result id from the operation-location header: ${operationLocationHeader}`);
    }
    return match[1];
}
/**
 * Returns the operation-id from the initialResponse header
 */
export function parseResultIdFromResponse(initialResponse) {
    const operationLocationHeader = initialResponse.headers["operation-location"];
    return parseResultId(operationLocationHeader);
}
/**
 * Converts a Rest Client response to a response that the LRO implementation understands
 * @param response - a rest client http response
 * @returns - An LRO response that the LRO implementation understands
 */
function getLroResponse(response) {
    if (Number.isNaN(response.status)) {
        throw new TypeError(`Status code of the response is not a number. Value: ${response.status}`);
    }
    return {
        flatResponse: response,
        rawResponse: Object.assign(Object.assign({}, response), { statusCode: Number.parseInt(response.status), body: response.body }),
    };
}
//# sourceMappingURL=pollingHelper.js.map