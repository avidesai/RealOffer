{"version":3,"file":"paginateHelper.js","sourceRoot":"","sources":["../../src/paginateHelper.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { Client, PathUncheckedResponse } from \"@azure-rest/core-client\";\nimport { createRestError } from \"@azure-rest/core-client\";\n\n/**\n * returns an async iterator that iterates over results. It also has a `byPage`\n * method that returns pages of items at once.\n *\n * @param pagedResult - an object that specifies how to get pages.\n * @returns a paged async iterator that iterates over results.\n */\nfunction getPagedAsyncIterator<\n  TElement,\n  TPage = TElement[],\n  TPageSettings = PageSettings,\n  TLink = string,\n>(\n  pagedResult: PagedResult<TPage, TPageSettings, TLink>,\n): PagedAsyncIterableIterator<TElement, TPage, TPageSettings> {\n  const iter = getItemAsyncIterator<TElement, TPage, TLink, TPageSettings>(pagedResult);\n  return {\n    next() {\n      return iter.next();\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n    byPage:\n      pagedResult?.byPage ??\n      (((settings?: PageSettings) => {\n        const { continuationToken } = settings ?? {};\n        return getPageAsyncIterator(pagedResult, {\n          pageLink: continuationToken as unknown as TLink | undefined,\n        });\n      }) as unknown as (settings?: TPageSettings) => AsyncIterableIterator<TPage>),\n  };\n}\n\nasync function* getItemAsyncIterator<TElement, TPage, TLink, TPageSettings>(\n  pagedResult: PagedResult<TPage, TPageSettings, TLink>,\n): AsyncIterableIterator<TElement> {\n  const pages = getPageAsyncIterator(pagedResult);\n  const firstVal = await pages.next();\n  // if the result does not have an array shape, i.e. TPage = TElement, then we return it as is\n  if (!Array.isArray(firstVal.value)) {\n    // can extract elements from this page\n    const { toElements } = pagedResult;\n    if (toElements) {\n      yield* toElements(firstVal.value) as TElement[];\n      for await (const page of pages) {\n        yield* toElements(page) as TElement[];\n      }\n    } else {\n      yield firstVal.value;\n      // `pages` is of type `AsyncIterableIterator<TPage>` but TPage = TElement in this case\n      yield* pages as unknown as AsyncIterableIterator<TElement>;\n    }\n  } else {\n    yield* firstVal.value;\n    for await (const page of pages) {\n      // pages is of type `AsyncIterableIterator<TPage>` so `page` is of type `TPage`. In this branch,\n      // it must be the case that `TPage = TElement[]`\n      yield* page as unknown as TElement[];\n    }\n  }\n}\n\nasync function* getPageAsyncIterator<TPage, TLink, TPageSettings>(\n  pagedResult: PagedResult<TPage, TPageSettings, TLink>,\n  options: {\n    pageLink?: TLink;\n  } = {},\n): AsyncIterableIterator<TPage> {\n  const { pageLink } = options;\n  let response = await pagedResult.getPage(pageLink ?? pagedResult.firstPageLink);\n  if (!response) {\n    return;\n  }\n  yield response.page;\n  while (response.nextPageLink) {\n    response = await pagedResult.getPage(response.nextPageLink);\n    if (!response) {\n      return;\n    }\n    yield response.page;\n  }\n}\n\n/**\n * An interface that tracks the settings for paged iteration\n */\nexport interface PageSettings {\n  /**\n   * The token that keeps track of where to continue the iterator\n   */\n  continuationToken?: string;\n}\n\n/**\n * An interface that allows async iterable iteration both to completion and by page.\n */\nexport interface PagedAsyncIterableIterator<\n  TElement,\n  TPage = TElement[],\n  TPageSettings = PageSettings,\n> {\n  /**\n   * The next method, part of the iteration protocol\n   */\n  next(): Promise<IteratorResult<TElement>>;\n  /**\n   * The connection to the async iterator, part of the iteration protocol\n   */\n  [Symbol.asyncIterator](): PagedAsyncIterableIterator<TElement, TPage, TPageSettings>;\n  /**\n   * Return an AsyncIterableIterator that works a page at a time\n   */\n  byPage: (settings?: TPageSettings) => AsyncIterableIterator<TPage>;\n}\n\n/**\n * An interface that describes how to communicate with the service.\n */\ninterface PagedResult<TPage, TPageSettings = PageSettings, TLink = string> {\n  /**\n   * Link to the first page of results.\n   */\n  firstPageLink: TLink;\n  /**\n   * A method that returns a page of results.\n   */\n  getPage: (pageLink: TLink) => Promise<{ page: TPage; nextPageLink?: TLink } | undefined>;\n  /**\n   * a function to implement the `byPage` method on the paged async iterator.\n   */\n  byPage?: (settings?: TPageSettings) => AsyncIterableIterator<TPage>;\n\n  /**\n   * A function to extract elements from a page.\n   */\n  toElements?: (page: TPage) => unknown[];\n}\n\n/**\n * Helper type to extract the type of an array\n */\nexport type GetArrayType<T> = T extends Array<infer TData> ? TData : never;\n\n/**\n * The type of a custom function that defines how to get a page and a link to the next one if any.\n */\nexport type GetPage<TPage> = (pageLink: string) => Promise<{\n  page: TPage;\n  nextPageLink?: string;\n}>;\n\n/**\n * Options for the paging helper\n */\nexport interface PagingOptions<TResponse> {\n  /**\n   * Custom function to extract pagination details for crating the PagedAsyncIterableIterator\n   */\n  customGetPage?: GetPage<PaginateReturn<TResponse>[]>;\n}\n\n/**\n * Helper type to infer the Type of the paged elements from the response type\n * This type is generated based on the swagger information for x-ms-pageable\n * specifically on the itemName property which indicates the property of the response\n * where the page items are found. The default value is `value`.\n * This type will allow us to provide strongly typed Iterator based on the response we get as second parameter\n */\nexport type PaginateReturn<TResult> = TResult extends {\n  body: { value?: infer TPage };\n}\n  ? GetArrayType<TPage>\n  : Array<unknown>;\n\n/**\n * Helper to paginate results from an initial response that follows the specification of Autorest `x-ms-pageable` extension\n * @param client - Client to use for sending the next page requests\n * @param initialResponse - Initial response containing the nextLink and current page of elements\n * @param customGetPage - Optional - Function to define how to extract the page and next link to be used to paginate the results\n * @returns - PagedAsyncIterableIterator to iterate the elements\n */\nexport function paginate<TResponse extends PathUncheckedResponse>(\n  client: Client,\n  initialResponse: TResponse,\n  options: PagingOptions<TResponse> = {},\n): PagedAsyncIterableIterator<PaginateReturn<TResponse>> {\n  // Extract element type from initial response\n  type TElement = PaginateReturn<TResponse>;\n  let firstRun = true;\n  const itemName = \"value\";\n  const nextLinkName = \"nextLink\";\n  const { customGetPage } = options;\n  const pagedResult: PagedResult<TElement[]> = {\n    firstPageLink: \"\",\n    getPage:\n      typeof customGetPage === \"function\"\n        ? customGetPage\n        : async (pageLink: string) => {\n            const result = firstRun ? initialResponse : await client.pathUnchecked(pageLink).get();\n            firstRun = false;\n            checkPagingRequest(result);\n            const nextLink = getNextLink(result.body, nextLinkName);\n            const values = getElements<TElement>(result.body, itemName);\n            return {\n              page: values,\n              nextPageLink: nextLink,\n            };\n          },\n  };\n\n  return getPagedAsyncIterator(pagedResult);\n}\n\n/**\n * Gets for the value of nextLink in the body\n */\nfunction getNextLink(body: unknown, nextLinkName?: string): string | undefined {\n  if (!nextLinkName) {\n    return undefined;\n  }\n\n  const nextLink = (body as Record<string, unknown>)[nextLinkName];\n\n  if (typeof nextLink !== \"string\" && typeof nextLink !== \"undefined\") {\n    throw new Error(`Body Property ${nextLinkName} should be a string or undefined`);\n  }\n\n  return nextLink;\n}\n\n/**\n * Gets the elements of the current request in the body.\n */\nfunction getElements<T = unknown>(body: unknown, itemName: string): T[] {\n  const value = (body as Record<string, unknown>)[itemName] as T[];\n\n  // value has to be an array according to the x-ms-pageable extension.\n  // The fact that this must be an array is used above to calculate the\n  // type of elements in the page in PaginateReturn\n  if (!Array.isArray(value)) {\n    throw new Error(\n      `Couldn't paginate response\\n Body doesn't contain an array property with name: ${itemName}`,\n    );\n  }\n\n  return value ?? [];\n}\n\n/**\n * Checks if a request failed\n */\nfunction checkPagingRequest(response: PathUncheckedResponse): void {\n  const Http2xxStatusCodes = [\"200\", \"201\", \"202\", \"203\", \"204\", \"205\", \"206\", \"207\", \"208\", \"226\"];\n  if (!Http2xxStatusCodes.includes(response.status)) {\n    throw createRestError(\n      `Pagination failed with unexpected statusCode ${response.status}`,\n      response,\n    );\n  }\n}\n"]}